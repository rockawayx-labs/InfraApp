
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ecosystem
 * 
 */
export type Ecosystem = $Result.DefaultSelection<Prisma.$EcosystemPayload>
/**
 * Model AnsibleGroup
 * 
 */
export type AnsibleGroup = $Result.DefaultSelection<Prisma.$AnsibleGroupPayload>
/**
 * Model Server
 * 
 */
export type Server = $Result.DefaultSelection<Prisma.$ServerPayload>
/**
 * Model Environment
 * 
 */
export type Environment = $Result.DefaultSelection<Prisma.$EnvironmentPayload>
/**
 * Model Software
 * 
 */
export type Software = $Result.DefaultSelection<Prisma.$SoftwarePayload>
/**
 * Model SoftwareVersion
 * 
 */
export type SoftwareVersion = $Result.DefaultSelection<Prisma.$SoftwareVersionPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ecosystems
 * const ecosystems = await prisma.ecosystem.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ecosystems
   * const ecosystems = await prisma.ecosystem.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ecosystem`: Exposes CRUD operations for the **Ecosystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ecosystems
    * const ecosystems = await prisma.ecosystem.findMany()
    * ```
    */
  get ecosystem(): Prisma.EcosystemDelegate<ExtArgs>;

  /**
   * `prisma.ansibleGroup`: Exposes CRUD operations for the **AnsibleGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnsibleGroups
    * const ansibleGroups = await prisma.ansibleGroup.findMany()
    * ```
    */
  get ansibleGroup(): Prisma.AnsibleGroupDelegate<ExtArgs>;

  /**
   * `prisma.server`: Exposes CRUD operations for the **Server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servers
    * const servers = await prisma.server.findMany()
    * ```
    */
  get server(): Prisma.ServerDelegate<ExtArgs>;

  /**
   * `prisma.environment`: Exposes CRUD operations for the **Environment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Environments
    * const environments = await prisma.environment.findMany()
    * ```
    */
  get environment(): Prisma.EnvironmentDelegate<ExtArgs>;

  /**
   * `prisma.software`: Exposes CRUD operations for the **Software** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Software
    * const software = await prisma.software.findMany()
    * ```
    */
  get software(): Prisma.SoftwareDelegate<ExtArgs>;

  /**
   * `prisma.softwareVersion`: Exposes CRUD operations for the **SoftwareVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoftwareVersions
    * const softwareVersions = await prisma.softwareVersion.findMany()
    * ```
    */
  get softwareVersion(): Prisma.SoftwareVersionDelegate<ExtArgs>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ecosystem: 'Ecosystem',
    AnsibleGroup: 'AnsibleGroup',
    Server: 'Server',
    Environment: 'Environment',
    Software: 'Software',
    SoftwareVersion: 'SoftwareVersion',
    Approval: 'Approval'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'ecosystem' | 'ansibleGroup' | 'server' | 'environment' | 'software' | 'softwareVersion' | 'approval'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Ecosystem: {
        payload: Prisma.$EcosystemPayload<ExtArgs>
        fields: Prisma.EcosystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EcosystemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EcosystemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          findFirst: {
            args: Prisma.EcosystemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EcosystemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          findMany: {
            args: Prisma.EcosystemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>[]
          }
          create: {
            args: Prisma.EcosystemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          createMany: {
            args: Prisma.EcosystemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EcosystemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          update: {
            args: Prisma.EcosystemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          deleteMany: {
            args: Prisma.EcosystemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EcosystemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EcosystemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EcosystemPayload>
          }
          aggregate: {
            args: Prisma.EcosystemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEcosystem>
          }
          groupBy: {
            args: Prisma.EcosystemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EcosystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EcosystemCountArgs<ExtArgs>,
            result: $Utils.Optional<EcosystemCountAggregateOutputType> | number
          }
        }
      }
      AnsibleGroup: {
        payload: Prisma.$AnsibleGroupPayload<ExtArgs>
        fields: Prisma.AnsibleGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnsibleGroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnsibleGroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          findFirst: {
            args: Prisma.AnsibleGroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnsibleGroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          findMany: {
            args: Prisma.AnsibleGroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>[]
          }
          create: {
            args: Prisma.AnsibleGroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          createMany: {
            args: Prisma.AnsibleGroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnsibleGroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          update: {
            args: Prisma.AnsibleGroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          deleteMany: {
            args: Prisma.AnsibleGroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnsibleGroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnsibleGroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnsibleGroupPayload>
          }
          aggregate: {
            args: Prisma.AnsibleGroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnsibleGroup>
          }
          groupBy: {
            args: Prisma.AnsibleGroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnsibleGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnsibleGroupCountArgs<ExtArgs>,
            result: $Utils.Optional<AnsibleGroupCountAggregateOutputType> | number
          }
        }
      }
      Server: {
        payload: Prisma.$ServerPayload<ExtArgs>
        fields: Prisma.ServerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findFirst: {
            args: Prisma.ServerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findMany: {
            args: Prisma.ServerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          create: {
            args: Prisma.ServerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          createMany: {
            args: Prisma.ServerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          update: {
            args: Prisma.ServerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          deleteMany: {
            args: Prisma.ServerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          aggregate: {
            args: Prisma.ServerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServer>
          }
          groupBy: {
            args: Prisma.ServerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServerCountArgs<ExtArgs>,
            result: $Utils.Optional<ServerCountAggregateOutputType> | number
          }
        }
      }
      Environment: {
        payload: Prisma.$EnvironmentPayload<ExtArgs>
        fields: Prisma.EnvironmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvironmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvironmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findFirst: {
            args: Prisma.EnvironmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvironmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findMany: {
            args: Prisma.EnvironmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          create: {
            args: Prisma.EnvironmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          createMany: {
            args: Prisma.EnvironmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnvironmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          update: {
            args: Prisma.EnvironmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          deleteMany: {
            args: Prisma.EnvironmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnvironmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnvironmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          aggregate: {
            args: Prisma.EnvironmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnvironment>
          }
          groupBy: {
            args: Prisma.EnvironmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvironmentCountArgs<ExtArgs>,
            result: $Utils.Optional<EnvironmentCountAggregateOutputType> | number
          }
        }
      }
      Software: {
        payload: Prisma.$SoftwarePayload<ExtArgs>
        fields: Prisma.SoftwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoftwareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoftwareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findFirst: {
            args: Prisma.SoftwareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoftwareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findMany: {
            args: Prisma.SoftwareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>[]
          }
          create: {
            args: Prisma.SoftwareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          createMany: {
            args: Prisma.SoftwareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoftwareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          update: {
            args: Prisma.SoftwareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          deleteMany: {
            args: Prisma.SoftwareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoftwareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoftwareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          aggregate: {
            args: Prisma.SoftwareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoftware>
          }
          groupBy: {
            args: Prisma.SoftwareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoftwareCountArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareCountAggregateOutputType> | number
          }
        }
      }
      SoftwareVersion: {
        payload: Prisma.$SoftwareVersionPayload<ExtArgs>
        fields: Prisma.SoftwareVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoftwareVersionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoftwareVersionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          findFirst: {
            args: Prisma.SoftwareVersionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoftwareVersionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          findMany: {
            args: Prisma.SoftwareVersionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>[]
          }
          create: {
            args: Prisma.SoftwareVersionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          createMany: {
            args: Prisma.SoftwareVersionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoftwareVersionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          update: {
            args: Prisma.SoftwareVersionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          deleteMany: {
            args: Prisma.SoftwareVersionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoftwareVersionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoftwareVersionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwareVersionPayload>
          }
          aggregate: {
            args: Prisma.SoftwareVersionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoftwareVersion>
          }
          groupBy: {
            args: Prisma.SoftwareVersionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoftwareVersionCountArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareVersionCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>,
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EcosystemCountOutputType
   */

  export type EcosystemCountOutputType = {
    groups: number
  }

  export type EcosystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | EcosystemCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes

  /**
   * EcosystemCountOutputType without action
   */
  export type EcosystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcosystemCountOutputType
     */
    select?: EcosystemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EcosystemCountOutputType without action
   */
  export type EcosystemCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnsibleGroupWhereInput
  }



  /**
   * Count Type AnsibleGroupCountOutputType
   */

  export type AnsibleGroupCountOutputType = {
    servers: number
    softwares: number
  }

  export type AnsibleGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | AnsibleGroupCountOutputTypeCountServersArgs
    softwares?: boolean | AnsibleGroupCountOutputTypeCountSoftwaresArgs
  }

  // Custom InputTypes

  /**
   * AnsibleGroupCountOutputType without action
   */
  export type AnsibleGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroupCountOutputType
     */
    select?: AnsibleGroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AnsibleGroupCountOutputType without action
   */
  export type AnsibleGroupCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
  }


  /**
   * AnsibleGroupCountOutputType without action
   */
  export type AnsibleGroupCountOutputTypeCountSoftwaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }



  /**
   * Count Type ServerCountOutputType
   */

  export type ServerCountOutputType = {
    softwares: number
  }

  export type ServerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    softwares?: boolean | ServerCountOutputTypeCountSoftwaresArgs
  }

  // Custom InputTypes

  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerCountOutputType
     */
    select?: ServerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeCountSoftwaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareVersionWhereInput
  }



  /**
   * Count Type EnvironmentCountOutputType
   */

  export type EnvironmentCountOutputType = {
    servers: number
    approvals: number
  }

  export type EnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | EnvironmentCountOutputTypeCountServersArgs
    approvals?: boolean | EnvironmentCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentCountOutputType
     */
    select?: EnvironmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
  }


  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }



  /**
   * Count Type SoftwareCountOutputType
   */

  export type SoftwareCountOutputType = {
    versions: number
    ansible_groups: number
  }

  export type SoftwareCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | SoftwareCountOutputTypeCountVersionsArgs
    ansible_groups?: boolean | SoftwareCountOutputTypeCountAnsible_groupsArgs
  }

  // Custom InputTypes

  /**
   * SoftwareCountOutputType without action
   */
  export type SoftwareCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareCountOutputType
     */
    select?: SoftwareCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SoftwareCountOutputType without action
   */
  export type SoftwareCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareVersionWhereInput
  }


  /**
   * SoftwareCountOutputType without action
   */
  export type SoftwareCountOutputTypeCountAnsible_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnsibleGroupWhereInput
  }



  /**
   * Count Type SoftwareVersionCountOutputType
   */

  export type SoftwareVersionCountOutputType = {
    servers: number
    approvals: number
  }

  export type SoftwareVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | SoftwareVersionCountOutputTypeCountServersArgs
    approvals?: boolean | SoftwareVersionCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes

  /**
   * SoftwareVersionCountOutputType without action
   */
  export type SoftwareVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersionCountOutputType
     */
    select?: SoftwareVersionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SoftwareVersionCountOutputType without action
   */
  export type SoftwareVersionCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
  }


  /**
   * SoftwareVersionCountOutputType without action
   */
  export type SoftwareVersionCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Ecosystem
   */

  export type AggregateEcosystem = {
    _count: EcosystemCountAggregateOutputType | null
    _avg: EcosystemAvgAggregateOutputType | null
    _sum: EcosystemSumAggregateOutputType | null
    _min: EcosystemMinAggregateOutputType | null
    _max: EcosystemMaxAggregateOutputType | null
  }

  export type EcosystemAvgAggregateOutputType = {
    id: number | null
  }

  export type EcosystemSumAggregateOutputType = {
    id: number | null
  }

  export type EcosystemMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EcosystemMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EcosystemCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type EcosystemAvgAggregateInputType = {
    id?: true
  }

  export type EcosystemSumAggregateInputType = {
    id?: true
  }

  export type EcosystemMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EcosystemMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EcosystemCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EcosystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ecosystem to aggregate.
     */
    where?: EcosystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ecosystems to fetch.
     */
    orderBy?: EcosystemOrderByWithRelationInput | EcosystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EcosystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ecosystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ecosystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ecosystems
    **/
    _count?: true | EcosystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EcosystemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EcosystemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EcosystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EcosystemMaxAggregateInputType
  }

  export type GetEcosystemAggregateType<T extends EcosystemAggregateArgs> = {
        [P in keyof T & keyof AggregateEcosystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEcosystem[P]>
      : GetScalarType<T[P], AggregateEcosystem[P]>
  }




  export type EcosystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcosystemWhereInput
    orderBy?: EcosystemOrderByWithAggregationInput | EcosystemOrderByWithAggregationInput[]
    by: EcosystemScalarFieldEnum[] | EcosystemScalarFieldEnum
    having?: EcosystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EcosystemCountAggregateInputType | true
    _avg?: EcosystemAvgAggregateInputType
    _sum?: EcosystemSumAggregateInputType
    _min?: EcosystemMinAggregateInputType
    _max?: EcosystemMaxAggregateInputType
  }

  export type EcosystemGroupByOutputType = {
    id: number
    name: string
    _count: EcosystemCountAggregateOutputType | null
    _avg: EcosystemAvgAggregateOutputType | null
    _sum: EcosystemSumAggregateOutputType | null
    _min: EcosystemMinAggregateOutputType | null
    _max: EcosystemMaxAggregateOutputType | null
  }

  type GetEcosystemGroupByPayload<T extends EcosystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EcosystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EcosystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EcosystemGroupByOutputType[P]>
            : GetScalarType<T[P], EcosystemGroupByOutputType[P]>
        }
      >
    >


  export type EcosystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    groups?: boolean | Ecosystem$groupsArgs<ExtArgs>
    _count?: boolean | EcosystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecosystem"]>

  export type EcosystemSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type EcosystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | Ecosystem$groupsArgs<ExtArgs>
    _count?: boolean | EcosystemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EcosystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ecosystem"
    objects: {
      groups: Prisma.$AnsibleGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["ecosystem"]>
    composites: {}
  }


  type EcosystemGetPayload<S extends boolean | null | undefined | EcosystemDefaultArgs> = $Result.GetResult<Prisma.$EcosystemPayload, S>

  type EcosystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EcosystemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EcosystemCountAggregateInputType | true
    }

  export interface EcosystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ecosystem'], meta: { name: 'Ecosystem' } }
    /**
     * Find zero or one Ecosystem that matches the filter.
     * @param {EcosystemFindUniqueArgs} args - Arguments to find a Ecosystem
     * @example
     * // Get one Ecosystem
     * const ecosystem = await prisma.ecosystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EcosystemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemFindUniqueArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ecosystem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EcosystemFindUniqueOrThrowArgs} args - Arguments to find a Ecosystem
     * @example
     * // Get one Ecosystem
     * const ecosystem = await prisma.ecosystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EcosystemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ecosystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemFindFirstArgs} args - Arguments to find a Ecosystem
     * @example
     * // Get one Ecosystem
     * const ecosystem = await prisma.ecosystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EcosystemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemFindFirstArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ecosystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemFindFirstOrThrowArgs} args - Arguments to find a Ecosystem
     * @example
     * // Get one Ecosystem
     * const ecosystem = await prisma.ecosystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EcosystemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ecosystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ecosystems
     * const ecosystems = await prisma.ecosystem.findMany()
     * 
     * // Get first 10 Ecosystems
     * const ecosystems = await prisma.ecosystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ecosystemWithIdOnly = await prisma.ecosystem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EcosystemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ecosystem.
     * @param {EcosystemCreateArgs} args - Arguments to create a Ecosystem.
     * @example
     * // Create one Ecosystem
     * const Ecosystem = await prisma.ecosystem.create({
     *   data: {
     *     // ... data to create a Ecosystem
     *   }
     * })
     * 
    **/
    create<T extends EcosystemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemCreateArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ecosystems.
     *     @param {EcosystemCreateManyArgs} args - Arguments to create many Ecosystems.
     *     @example
     *     // Create many Ecosystems
     *     const ecosystem = await prisma.ecosystem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EcosystemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ecosystem.
     * @param {EcosystemDeleteArgs} args - Arguments to delete one Ecosystem.
     * @example
     * // Delete one Ecosystem
     * const Ecosystem = await prisma.ecosystem.delete({
     *   where: {
     *     // ... filter to delete one Ecosystem
     *   }
     * })
     * 
    **/
    delete<T extends EcosystemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemDeleteArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ecosystem.
     * @param {EcosystemUpdateArgs} args - Arguments to update one Ecosystem.
     * @example
     * // Update one Ecosystem
     * const ecosystem = await prisma.ecosystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EcosystemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemUpdateArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ecosystems.
     * @param {EcosystemDeleteManyArgs} args - Arguments to filter Ecosystems to delete.
     * @example
     * // Delete a few Ecosystems
     * const { count } = await prisma.ecosystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EcosystemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EcosystemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ecosystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ecosystems
     * const ecosystem = await prisma.ecosystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EcosystemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ecosystem.
     * @param {EcosystemUpsertArgs} args - Arguments to update or create a Ecosystem.
     * @example
     * // Update or create a Ecosystem
     * const ecosystem = await prisma.ecosystem.upsert({
     *   create: {
     *     // ... data to create a Ecosystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ecosystem we want to update
     *   }
     * })
    **/
    upsert<T extends EcosystemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EcosystemUpsertArgs<ExtArgs>>
    ): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ecosystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemCountArgs} args - Arguments to filter Ecosystems to count.
     * @example
     * // Count the number of Ecosystems
     * const count = await prisma.ecosystem.count({
     *   where: {
     *     // ... the filter for the Ecosystems we want to count
     *   }
     * })
    **/
    count<T extends EcosystemCountArgs>(
      args?: Subset<T, EcosystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EcosystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ecosystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EcosystemAggregateArgs>(args: Subset<T, EcosystemAggregateArgs>): Prisma.PrismaPromise<GetEcosystemAggregateType<T>>

    /**
     * Group by Ecosystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcosystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EcosystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EcosystemGroupByArgs['orderBy'] }
        : { orderBy?: EcosystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EcosystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEcosystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ecosystem model
   */
  readonly fields: EcosystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ecosystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EcosystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groups<T extends Ecosystem$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Ecosystem$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ecosystem model
   */ 
  interface EcosystemFieldRefs {
    readonly id: FieldRef<"Ecosystem", 'Int'>
    readonly name: FieldRef<"Ecosystem", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Ecosystem findUnique
   */
  export type EcosystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter, which Ecosystem to fetch.
     */
    where: EcosystemWhereUniqueInput
  }


  /**
   * Ecosystem findUniqueOrThrow
   */
  export type EcosystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter, which Ecosystem to fetch.
     */
    where: EcosystemWhereUniqueInput
  }


  /**
   * Ecosystem findFirst
   */
  export type EcosystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter, which Ecosystem to fetch.
     */
    where?: EcosystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ecosystems to fetch.
     */
    orderBy?: EcosystemOrderByWithRelationInput | EcosystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ecosystems.
     */
    cursor?: EcosystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ecosystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ecosystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ecosystems.
     */
    distinct?: EcosystemScalarFieldEnum | EcosystemScalarFieldEnum[]
  }


  /**
   * Ecosystem findFirstOrThrow
   */
  export type EcosystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter, which Ecosystem to fetch.
     */
    where?: EcosystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ecosystems to fetch.
     */
    orderBy?: EcosystemOrderByWithRelationInput | EcosystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ecosystems.
     */
    cursor?: EcosystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ecosystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ecosystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ecosystems.
     */
    distinct?: EcosystemScalarFieldEnum | EcosystemScalarFieldEnum[]
  }


  /**
   * Ecosystem findMany
   */
  export type EcosystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter, which Ecosystems to fetch.
     */
    where?: EcosystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ecosystems to fetch.
     */
    orderBy?: EcosystemOrderByWithRelationInput | EcosystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ecosystems.
     */
    cursor?: EcosystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ecosystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ecosystems.
     */
    skip?: number
    distinct?: EcosystemScalarFieldEnum | EcosystemScalarFieldEnum[]
  }


  /**
   * Ecosystem create
   */
  export type EcosystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * The data needed to create a Ecosystem.
     */
    data: XOR<EcosystemCreateInput, EcosystemUncheckedCreateInput>
  }


  /**
   * Ecosystem createMany
   */
  export type EcosystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ecosystems.
     */
    data: EcosystemCreateManyInput | EcosystemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ecosystem update
   */
  export type EcosystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * The data needed to update a Ecosystem.
     */
    data: XOR<EcosystemUpdateInput, EcosystemUncheckedUpdateInput>
    /**
     * Choose, which Ecosystem to update.
     */
    where: EcosystemWhereUniqueInput
  }


  /**
   * Ecosystem updateMany
   */
  export type EcosystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ecosystems.
     */
    data: XOR<EcosystemUpdateManyMutationInput, EcosystemUncheckedUpdateManyInput>
    /**
     * Filter which Ecosystems to update
     */
    where?: EcosystemWhereInput
  }


  /**
   * Ecosystem upsert
   */
  export type EcosystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * The filter to search for the Ecosystem to update in case it exists.
     */
    where: EcosystemWhereUniqueInput
    /**
     * In case the Ecosystem found by the `where` argument doesn't exist, create a new Ecosystem with this data.
     */
    create: XOR<EcosystemCreateInput, EcosystemUncheckedCreateInput>
    /**
     * In case the Ecosystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EcosystemUpdateInput, EcosystemUncheckedUpdateInput>
  }


  /**
   * Ecosystem delete
   */
  export type EcosystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    /**
     * Filter which Ecosystem to delete.
     */
    where: EcosystemWhereUniqueInput
  }


  /**
   * Ecosystem deleteMany
   */
  export type EcosystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ecosystems to delete
     */
    where?: EcosystemWhereInput
  }


  /**
   * Ecosystem.groups
   */
  export type Ecosystem$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    where?: AnsibleGroupWhereInput
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    cursor?: AnsibleGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnsibleGroupScalarFieldEnum | AnsibleGroupScalarFieldEnum[]
  }


  /**
   * Ecosystem without action
   */
  export type EcosystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
  }



  /**
   * Model AnsibleGroup
   */

  export type AggregateAnsibleGroup = {
    _count: AnsibleGroupCountAggregateOutputType | null
    _avg: AnsibleGroupAvgAggregateOutputType | null
    _sum: AnsibleGroupSumAggregateOutputType | null
    _min: AnsibleGroupMinAggregateOutputType | null
    _max: AnsibleGroupMaxAggregateOutputType | null
  }

  export type AnsibleGroupAvgAggregateOutputType = {
    id: number | null
    ecosystem_id: number | null
  }

  export type AnsibleGroupSumAggregateOutputType = {
    id: number | null
    ecosystem_id: number | null
  }

  export type AnsibleGroupMinAggregateOutputType = {
    id: number | null
    group_name: string | null
    ecosystem_id: number | null
  }

  export type AnsibleGroupMaxAggregateOutputType = {
    id: number | null
    group_name: string | null
    ecosystem_id: number | null
  }

  export type AnsibleGroupCountAggregateOutputType = {
    id: number
    group_name: number
    ecosystem_id: number
    _all: number
  }


  export type AnsibleGroupAvgAggregateInputType = {
    id?: true
    ecosystem_id?: true
  }

  export type AnsibleGroupSumAggregateInputType = {
    id?: true
    ecosystem_id?: true
  }

  export type AnsibleGroupMinAggregateInputType = {
    id?: true
    group_name?: true
    ecosystem_id?: true
  }

  export type AnsibleGroupMaxAggregateInputType = {
    id?: true
    group_name?: true
    ecosystem_id?: true
  }

  export type AnsibleGroupCountAggregateInputType = {
    id?: true
    group_name?: true
    ecosystem_id?: true
    _all?: true
  }

  export type AnsibleGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnsibleGroup to aggregate.
     */
    where?: AnsibleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnsibleGroups to fetch.
     */
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnsibleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnsibleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnsibleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnsibleGroups
    **/
    _count?: true | AnsibleGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnsibleGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnsibleGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnsibleGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnsibleGroupMaxAggregateInputType
  }

  export type GetAnsibleGroupAggregateType<T extends AnsibleGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateAnsibleGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnsibleGroup[P]>
      : GetScalarType<T[P], AggregateAnsibleGroup[P]>
  }




  export type AnsibleGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnsibleGroupWhereInput
    orderBy?: AnsibleGroupOrderByWithAggregationInput | AnsibleGroupOrderByWithAggregationInput[]
    by: AnsibleGroupScalarFieldEnum[] | AnsibleGroupScalarFieldEnum
    having?: AnsibleGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnsibleGroupCountAggregateInputType | true
    _avg?: AnsibleGroupAvgAggregateInputType
    _sum?: AnsibleGroupSumAggregateInputType
    _min?: AnsibleGroupMinAggregateInputType
    _max?: AnsibleGroupMaxAggregateInputType
  }

  export type AnsibleGroupGroupByOutputType = {
    id: number
    group_name: string | null
    ecosystem_id: number
    _count: AnsibleGroupCountAggregateOutputType | null
    _avg: AnsibleGroupAvgAggregateOutputType | null
    _sum: AnsibleGroupSumAggregateOutputType | null
    _min: AnsibleGroupMinAggregateOutputType | null
    _max: AnsibleGroupMaxAggregateOutputType | null
  }

  type GetAnsibleGroupGroupByPayload<T extends AnsibleGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnsibleGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnsibleGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnsibleGroupGroupByOutputType[P]>
            : GetScalarType<T[P], AnsibleGroupGroupByOutputType[P]>
        }
      >
    >


  export type AnsibleGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_name?: boolean
    ecosystem_id?: boolean
    ecosystem?: boolean | AnsibleGroup$ecosystemArgs<ExtArgs>
    servers?: boolean | AnsibleGroup$serversArgs<ExtArgs>
    softwares?: boolean | AnsibleGroup$softwaresArgs<ExtArgs>
    _count?: boolean | AnsibleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ansibleGroup"]>

  export type AnsibleGroupSelectScalar = {
    id?: boolean
    group_name?: boolean
    ecosystem_id?: boolean
  }

  export type AnsibleGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecosystem?: boolean | AnsibleGroup$ecosystemArgs<ExtArgs>
    servers?: boolean | AnsibleGroup$serversArgs<ExtArgs>
    softwares?: boolean | AnsibleGroup$softwaresArgs<ExtArgs>
    _count?: boolean | AnsibleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AnsibleGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnsibleGroup"
    objects: {
      ecosystem: Prisma.$EcosystemPayload<ExtArgs> | null
      servers: Prisma.$ServerPayload<ExtArgs>[]
      softwares: Prisma.$SoftwarePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group_name: string | null
      ecosystem_id: number
    }, ExtArgs["result"]["ansibleGroup"]>
    composites: {}
  }


  type AnsibleGroupGetPayload<S extends boolean | null | undefined | AnsibleGroupDefaultArgs> = $Result.GetResult<Prisma.$AnsibleGroupPayload, S>

  type AnsibleGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnsibleGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnsibleGroupCountAggregateInputType | true
    }

  export interface AnsibleGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnsibleGroup'], meta: { name: 'AnsibleGroup' } }
    /**
     * Find zero or one AnsibleGroup that matches the filter.
     * @param {AnsibleGroupFindUniqueArgs} args - Arguments to find a AnsibleGroup
     * @example
     * // Get one AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnsibleGroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AnsibleGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnsibleGroupFindUniqueOrThrowArgs} args - Arguments to find a AnsibleGroup
     * @example
     * // Get one AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnsibleGroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AnsibleGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupFindFirstArgs} args - Arguments to find a AnsibleGroup
     * @example
     * // Get one AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnsibleGroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupFindFirstArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AnsibleGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupFindFirstOrThrowArgs} args - Arguments to find a AnsibleGroup
     * @example
     * // Get one AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnsibleGroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AnsibleGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnsibleGroups
     * const ansibleGroups = await prisma.ansibleGroup.findMany()
     * 
     * // Get first 10 AnsibleGroups
     * const ansibleGroups = await prisma.ansibleGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ansibleGroupWithIdOnly = await prisma.ansibleGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnsibleGroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AnsibleGroup.
     * @param {AnsibleGroupCreateArgs} args - Arguments to create a AnsibleGroup.
     * @example
     * // Create one AnsibleGroup
     * const AnsibleGroup = await prisma.ansibleGroup.create({
     *   data: {
     *     // ... data to create a AnsibleGroup
     *   }
     * })
     * 
    **/
    create<T extends AnsibleGroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupCreateArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AnsibleGroups.
     *     @param {AnsibleGroupCreateManyArgs} args - Arguments to create many AnsibleGroups.
     *     @example
     *     // Create many AnsibleGroups
     *     const ansibleGroup = await prisma.ansibleGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnsibleGroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnsibleGroup.
     * @param {AnsibleGroupDeleteArgs} args - Arguments to delete one AnsibleGroup.
     * @example
     * // Delete one AnsibleGroup
     * const AnsibleGroup = await prisma.ansibleGroup.delete({
     *   where: {
     *     // ... filter to delete one AnsibleGroup
     *   }
     * })
     * 
    **/
    delete<T extends AnsibleGroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupDeleteArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AnsibleGroup.
     * @param {AnsibleGroupUpdateArgs} args - Arguments to update one AnsibleGroup.
     * @example
     * // Update one AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnsibleGroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupUpdateArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AnsibleGroups.
     * @param {AnsibleGroupDeleteManyArgs} args - Arguments to filter AnsibleGroups to delete.
     * @example
     * // Delete a few AnsibleGroups
     * const { count } = await prisma.ansibleGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnsibleGroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnsibleGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnsibleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnsibleGroups
     * const ansibleGroup = await prisma.ansibleGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnsibleGroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnsibleGroup.
     * @param {AnsibleGroupUpsertArgs} args - Arguments to update or create a AnsibleGroup.
     * @example
     * // Update or create a AnsibleGroup
     * const ansibleGroup = await prisma.ansibleGroup.upsert({
     *   create: {
     *     // ... data to create a AnsibleGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnsibleGroup we want to update
     *   }
     * })
    **/
    upsert<T extends AnsibleGroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnsibleGroupUpsertArgs<ExtArgs>>
    ): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AnsibleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupCountArgs} args - Arguments to filter AnsibleGroups to count.
     * @example
     * // Count the number of AnsibleGroups
     * const count = await prisma.ansibleGroup.count({
     *   where: {
     *     // ... the filter for the AnsibleGroups we want to count
     *   }
     * })
    **/
    count<T extends AnsibleGroupCountArgs>(
      args?: Subset<T, AnsibleGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnsibleGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnsibleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnsibleGroupAggregateArgs>(args: Subset<T, AnsibleGroupAggregateArgs>): Prisma.PrismaPromise<GetAnsibleGroupAggregateType<T>>

    /**
     * Group by AnsibleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnsibleGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnsibleGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnsibleGroupGroupByArgs['orderBy'] }
        : { orderBy?: AnsibleGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnsibleGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnsibleGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnsibleGroup model
   */
  readonly fields: AnsibleGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnsibleGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnsibleGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ecosystem<T extends AnsibleGroup$ecosystemArgs<ExtArgs> = {}>(args?: Subset<T, AnsibleGroup$ecosystemArgs<ExtArgs>>): Prisma__EcosystemClient<$Result.GetResult<Prisma.$EcosystemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    servers<T extends AnsibleGroup$serversArgs<ExtArgs> = {}>(args?: Subset<T, AnsibleGroup$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findMany'> | Null>;

    softwares<T extends AnsibleGroup$softwaresArgs<ExtArgs> = {}>(args?: Subset<T, AnsibleGroup$softwaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AnsibleGroup model
   */ 
  interface AnsibleGroupFieldRefs {
    readonly id: FieldRef<"AnsibleGroup", 'Int'>
    readonly group_name: FieldRef<"AnsibleGroup", 'String'>
    readonly ecosystem_id: FieldRef<"AnsibleGroup", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * AnsibleGroup findUnique
   */
  export type AnsibleGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter, which AnsibleGroup to fetch.
     */
    where: AnsibleGroupWhereUniqueInput
  }


  /**
   * AnsibleGroup findUniqueOrThrow
   */
  export type AnsibleGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter, which AnsibleGroup to fetch.
     */
    where: AnsibleGroupWhereUniqueInput
  }


  /**
   * AnsibleGroup findFirst
   */
  export type AnsibleGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter, which AnsibleGroup to fetch.
     */
    where?: AnsibleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnsibleGroups to fetch.
     */
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnsibleGroups.
     */
    cursor?: AnsibleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnsibleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnsibleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnsibleGroups.
     */
    distinct?: AnsibleGroupScalarFieldEnum | AnsibleGroupScalarFieldEnum[]
  }


  /**
   * AnsibleGroup findFirstOrThrow
   */
  export type AnsibleGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter, which AnsibleGroup to fetch.
     */
    where?: AnsibleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnsibleGroups to fetch.
     */
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnsibleGroups.
     */
    cursor?: AnsibleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnsibleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnsibleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnsibleGroups.
     */
    distinct?: AnsibleGroupScalarFieldEnum | AnsibleGroupScalarFieldEnum[]
  }


  /**
   * AnsibleGroup findMany
   */
  export type AnsibleGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter, which AnsibleGroups to fetch.
     */
    where?: AnsibleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnsibleGroups to fetch.
     */
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnsibleGroups.
     */
    cursor?: AnsibleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnsibleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnsibleGroups.
     */
    skip?: number
    distinct?: AnsibleGroupScalarFieldEnum | AnsibleGroupScalarFieldEnum[]
  }


  /**
   * AnsibleGroup create
   */
  export type AnsibleGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a AnsibleGroup.
     */
    data: XOR<AnsibleGroupCreateInput, AnsibleGroupUncheckedCreateInput>
  }


  /**
   * AnsibleGroup createMany
   */
  export type AnsibleGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnsibleGroups.
     */
    data: AnsibleGroupCreateManyInput | AnsibleGroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AnsibleGroup update
   */
  export type AnsibleGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a AnsibleGroup.
     */
    data: XOR<AnsibleGroupUpdateInput, AnsibleGroupUncheckedUpdateInput>
    /**
     * Choose, which AnsibleGroup to update.
     */
    where: AnsibleGroupWhereUniqueInput
  }


  /**
   * AnsibleGroup updateMany
   */
  export type AnsibleGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnsibleGroups.
     */
    data: XOR<AnsibleGroupUpdateManyMutationInput, AnsibleGroupUncheckedUpdateManyInput>
    /**
     * Filter which AnsibleGroups to update
     */
    where?: AnsibleGroupWhereInput
  }


  /**
   * AnsibleGroup upsert
   */
  export type AnsibleGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the AnsibleGroup to update in case it exists.
     */
    where: AnsibleGroupWhereUniqueInput
    /**
     * In case the AnsibleGroup found by the `where` argument doesn't exist, create a new AnsibleGroup with this data.
     */
    create: XOR<AnsibleGroupCreateInput, AnsibleGroupUncheckedCreateInput>
    /**
     * In case the AnsibleGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnsibleGroupUpdateInput, AnsibleGroupUncheckedUpdateInput>
  }


  /**
   * AnsibleGroup delete
   */
  export type AnsibleGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    /**
     * Filter which AnsibleGroup to delete.
     */
    where: AnsibleGroupWhereUniqueInput
  }


  /**
   * AnsibleGroup deleteMany
   */
  export type AnsibleGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnsibleGroups to delete
     */
    where?: AnsibleGroupWhereInput
  }


  /**
   * AnsibleGroup.ecosystem
   */
  export type AnsibleGroup$ecosystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ecosystem
     */
    select?: EcosystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EcosystemInclude<ExtArgs> | null
    where?: EcosystemWhereInput
  }


  /**
   * AnsibleGroup.servers
   */
  export type AnsibleGroup$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    cursor?: ServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * AnsibleGroup.softwares
   */
  export type AnsibleGroup$softwaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * AnsibleGroup without action
   */
  export type AnsibleGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
  }



  /**
   * Model Server
   */

  export type AggregateServer = {
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  export type ServerAvgAggregateOutputType = {
    id: number | null
    ansible_group_id: number | null
    environment_id: number | null
  }

  export type ServerSumAggregateOutputType = {
    id: number | null
    ansible_group_id: number | null
    environment_id: number | null
  }

  export type ServerMinAggregateOutputType = {
    id: number | null
    hostname: string | null
    ansible_group_id: number | null
    date_created: Date | null
    date_changed: Date | null
    environment_id: number | null
  }

  export type ServerMaxAggregateOutputType = {
    id: number | null
    hostname: string | null
    ansible_group_id: number | null
    date_created: Date | null
    date_changed: Date | null
    environment_id: number | null
  }

  export type ServerCountAggregateOutputType = {
    id: number
    hostname: number
    ansible_group_id: number
    date_created: number
    date_changed: number
    environment_id: number
    _all: number
  }


  export type ServerAvgAggregateInputType = {
    id?: true
    ansible_group_id?: true
    environment_id?: true
  }

  export type ServerSumAggregateInputType = {
    id?: true
    ansible_group_id?: true
    environment_id?: true
  }

  export type ServerMinAggregateInputType = {
    id?: true
    hostname?: true
    ansible_group_id?: true
    date_created?: true
    date_changed?: true
    environment_id?: true
  }

  export type ServerMaxAggregateInputType = {
    id?: true
    hostname?: true
    ansible_group_id?: true
    date_created?: true
    date_changed?: true
    environment_id?: true
  }

  export type ServerCountAggregateInputType = {
    id?: true
    hostname?: true
    ansible_group_id?: true
    date_created?: true
    date_changed?: true
    environment_id?: true
    _all?: true
  }

  export type ServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Server to aggregate.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servers
    **/
    _count?: true | ServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerMaxAggregateInputType
  }

  export type GetServerAggregateType<T extends ServerAggregateArgs> = {
        [P in keyof T & keyof AggregateServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer[P]>
      : GetScalarType<T[P], AggregateServer[P]>
  }




  export type ServerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithAggregationInput | ServerOrderByWithAggregationInput[]
    by: ServerScalarFieldEnum[] | ServerScalarFieldEnum
    having?: ServerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerCountAggregateInputType | true
    _avg?: ServerAvgAggregateInputType
    _sum?: ServerSumAggregateInputType
    _min?: ServerMinAggregateInputType
    _max?: ServerMaxAggregateInputType
  }

  export type ServerGroupByOutputType = {
    id: number
    hostname: string
    ansible_group_id: number | null
    date_created: Date
    date_changed: Date
    environment_id: number | null
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  type GetServerGroupByPayload<T extends ServerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerGroupByOutputType[P]>
            : GetScalarType<T[P], ServerGroupByOutputType[P]>
        }
      >
    >


  export type ServerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostname?: boolean
    ansible_group_id?: boolean
    date_created?: boolean
    date_changed?: boolean
    environment_id?: boolean
    ansible_group?: boolean | Server$ansible_groupArgs<ExtArgs>
    environment?: boolean | Server$environmentArgs<ExtArgs>
    softwares?: boolean | Server$softwaresArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["server"]>

  export type ServerSelectScalar = {
    id?: boolean
    hostname?: boolean
    ansible_group_id?: boolean
    date_created?: boolean
    date_changed?: boolean
    environment_id?: boolean
  }

  export type ServerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ansible_group?: boolean | Server$ansible_groupArgs<ExtArgs>
    environment?: boolean | Server$environmentArgs<ExtArgs>
    softwares?: boolean | Server$softwaresArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Server"
    objects: {
      ansible_group: Prisma.$AnsibleGroupPayload<ExtArgs> | null
      environment: Prisma.$EnvironmentPayload<ExtArgs> | null
      softwares: Prisma.$SoftwareVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hostname: string
      ansible_group_id: number | null
      date_created: Date
      date_changed: Date
      environment_id: number | null
    }, ExtArgs["result"]["server"]>
    composites: {}
  }


  type ServerGetPayload<S extends boolean | null | undefined | ServerDefaultArgs> = $Result.GetResult<Prisma.$ServerPayload, S>

  type ServerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServerCountAggregateInputType | true
    }

  export interface ServerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Server'], meta: { name: 'Server' } }
    /**
     * Find zero or one Server that matches the filter.
     * @param {ServerFindUniqueArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServerFindUniqueArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Server that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServerFindUniqueOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerFindFirstArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servers
     * const servers = await prisma.server.findMany()
     * 
     * // Get first 10 Servers
     * const servers = await prisma.server.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serverWithIdOnly = await prisma.server.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Server.
     * @param {ServerCreateArgs} args - Arguments to create a Server.
     * @example
     * // Create one Server
     * const Server = await prisma.server.create({
     *   data: {
     *     // ... data to create a Server
     *   }
     * })
     * 
    **/
    create<T extends ServerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServerCreateArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Servers.
     *     @param {ServerCreateManyArgs} args - Arguments to create many Servers.
     *     @example
     *     // Create many Servers
     *     const server = await prisma.server.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server.
     * @param {ServerDeleteArgs} args - Arguments to delete one Server.
     * @example
     * // Delete one Server
     * const Server = await prisma.server.delete({
     *   where: {
     *     // ... filter to delete one Server
     *   }
     * })
     * 
    **/
    delete<T extends ServerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServerDeleteArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Server.
     * @param {ServerUpdateArgs} args - Arguments to update one Server.
     * @example
     * // Update one Server
     * const server = await prisma.server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServerUpdateArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Servers.
     * @param {ServerDeleteManyArgs} args - Arguments to filter Servers to delete.
     * @example
     * // Delete a few Servers
     * const { count } = await prisma.server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servers
     * const server = await prisma.server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server.
     * @param {ServerUpsertArgs} args - Arguments to update or create a Server.
     * @example
     * // Update or create a Server
     * const server = await prisma.server.upsert({
     *   create: {
     *     // ... data to create a Server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server we want to update
     *   }
     * })
    **/
    upsert<T extends ServerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServerUpsertArgs<ExtArgs>>
    ): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerCountArgs} args - Arguments to filter Servers to count.
     * @example
     * // Count the number of Servers
     * const count = await prisma.server.count({
     *   where: {
     *     // ... the filter for the Servers we want to count
     *   }
     * })
    **/
    count<T extends ServerCountArgs>(
      args?: Subset<T, ServerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerAggregateArgs>(args: Subset<T, ServerAggregateArgs>): Prisma.PrismaPromise<GetServerAggregateType<T>>

    /**
     * Group by Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServerGroupByArgs['orderBy'] }
        : { orderBy?: ServerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Server model
   */
  readonly fields: ServerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ansible_group<T extends Server$ansible_groupArgs<ExtArgs> = {}>(args?: Subset<T, Server$ansible_groupArgs<ExtArgs>>): Prisma__AnsibleGroupClient<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    environment<T extends Server$environmentArgs<ExtArgs> = {}>(args?: Subset<T, Server$environmentArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    softwares<T extends Server$softwaresArgs<ExtArgs> = {}>(args?: Subset<T, Server$softwaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Server model
   */ 
  interface ServerFieldRefs {
    readonly id: FieldRef<"Server", 'Int'>
    readonly hostname: FieldRef<"Server", 'String'>
    readonly ansible_group_id: FieldRef<"Server", 'Int'>
    readonly date_created: FieldRef<"Server", 'DateTime'>
    readonly date_changed: FieldRef<"Server", 'DateTime'>
    readonly environment_id: FieldRef<"Server", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Server findUnique
   */
  export type ServerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }


  /**
   * Server findUniqueOrThrow
   */
  export type ServerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }


  /**
   * Server findFirst
   */
  export type ServerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * Server findFirstOrThrow
   */
  export type ServerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * Server findMany
   */
  export type ServerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Servers to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * Server create
   */
  export type ServerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The data needed to create a Server.
     */
    data: XOR<ServerCreateInput, ServerUncheckedCreateInput>
  }


  /**
   * Server createMany
   */
  export type ServerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servers.
     */
    data: ServerCreateManyInput | ServerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Server update
   */
  export type ServerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The data needed to update a Server.
     */
    data: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
    /**
     * Choose, which Server to update.
     */
    where: ServerWhereUniqueInput
  }


  /**
   * Server updateMany
   */
  export type ServerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servers.
     */
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyInput>
    /**
     * Filter which Servers to update
     */
    where?: ServerWhereInput
  }


  /**
   * Server upsert
   */
  export type ServerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The filter to search for the Server to update in case it exists.
     */
    where: ServerWhereUniqueInput
    /**
     * In case the Server found by the `where` argument doesn't exist, create a new Server with this data.
     */
    create: XOR<ServerCreateInput, ServerUncheckedCreateInput>
    /**
     * In case the Server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
  }


  /**
   * Server delete
   */
  export type ServerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter which Server to delete.
     */
    where: ServerWhereUniqueInput
  }


  /**
   * Server deleteMany
   */
  export type ServerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servers to delete
     */
    where?: ServerWhereInput
  }


  /**
   * Server.ansible_group
   */
  export type Server$ansible_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    where?: AnsibleGroupWhereInput
  }


  /**
   * Server.environment
   */
  export type Server$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    where?: EnvironmentWhereInput
  }


  /**
   * Server.softwares
   */
  export type Server$softwaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    cursor?: SoftwareVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareVersionScalarFieldEnum | SoftwareVersionScalarFieldEnum[]
  }


  /**
   * Server without action
   */
  export type ServerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
  }



  /**
   * Model Environment
   */

  export type AggregateEnvironment = {
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  export type EnvironmentAvgAggregateOutputType = {
    id: number | null
  }

  export type EnvironmentSumAggregateOutputType = {
    id: number | null
  }

  export type EnvironmentMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EnvironmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EnvironmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type EnvironmentAvgAggregateInputType = {
    id?: true
  }

  export type EnvironmentSumAggregateInputType = {
    id?: true
  }

  export type EnvironmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EnvironmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EnvironmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environment to aggregate.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Environments
    **/
    _count?: true | EnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvironmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvironmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentMaxAggregateInputType
  }

  export type GetEnvironmentAggregateType<T extends EnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironment[P]>
      : GetScalarType<T[P], AggregateEnvironment[P]>
  }




  export type EnvironmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentWhereInput
    orderBy?: EnvironmentOrderByWithAggregationInput | EnvironmentOrderByWithAggregationInput[]
    by: EnvironmentScalarFieldEnum[] | EnvironmentScalarFieldEnum
    having?: EnvironmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentCountAggregateInputType | true
    _avg?: EnvironmentAvgAggregateInputType
    _sum?: EnvironmentSumAggregateInputType
    _min?: EnvironmentMinAggregateInputType
    _max?: EnvironmentMaxAggregateInputType
  }

  export type EnvironmentGroupByOutputType = {
    id: number
    name: string
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  type GetEnvironmentGroupByPayload<T extends EnvironmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type EnvironmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    servers?: boolean | Environment$serversArgs<ExtArgs>
    approvals?: boolean | Environment$approvalsArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type EnvironmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | Environment$serversArgs<ExtArgs>
    approvals?: boolean | Environment$approvalsArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EnvironmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Environment"
    objects: {
      servers: Prisma.$ServerPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["environment"]>
    composites: {}
  }


  type EnvironmentGetPayload<S extends boolean | null | undefined | EnvironmentDefaultArgs> = $Result.GetResult<Prisma.$EnvironmentPayload, S>

  type EnvironmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnvironmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnvironmentCountAggregateInputType | true
    }

  export interface EnvironmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Environment'], meta: { name: 'Environment' } }
    /**
     * Find zero or one Environment that matches the filter.
     * @param {EnvironmentFindUniqueArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnvironmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentFindUniqueArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Environment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnvironmentFindUniqueOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnvironmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Environment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnvironmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentFindFirstArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Environment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnvironmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Environments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Environments
     * const environments = await prisma.environment.findMany()
     * 
     * // Get first 10 Environments
     * const environments = await prisma.environment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentWithIdOnly = await prisma.environment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnvironmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Environment.
     * @param {EnvironmentCreateArgs} args - Arguments to create a Environment.
     * @example
     * // Create one Environment
     * const Environment = await prisma.environment.create({
     *   data: {
     *     // ... data to create a Environment
     *   }
     * })
     * 
    **/
    create<T extends EnvironmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentCreateArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Environments.
     *     @param {EnvironmentCreateManyArgs} args - Arguments to create many Environments.
     *     @example
     *     // Create many Environments
     *     const environment = await prisma.environment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnvironmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Environment.
     * @param {EnvironmentDeleteArgs} args - Arguments to delete one Environment.
     * @example
     * // Delete one Environment
     * const Environment = await prisma.environment.delete({
     *   where: {
     *     // ... filter to delete one Environment
     *   }
     * })
     * 
    **/
    delete<T extends EnvironmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentDeleteArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Environment.
     * @param {EnvironmentUpdateArgs} args - Arguments to update one Environment.
     * @example
     * // Update one Environment
     * const environment = await prisma.environment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnvironmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentUpdateArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Environments.
     * @param {EnvironmentDeleteManyArgs} args - Arguments to filter Environments to delete.
     * @example
     * // Delete a few Environments
     * const { count } = await prisma.environment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnvironmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnvironmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Environment.
     * @param {EnvironmentUpsertArgs} args - Arguments to update or create a Environment.
     * @example
     * // Update or create a Environment
     * const environment = await prisma.environment.upsert({
     *   create: {
     *     // ... data to create a Environment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Environment we want to update
     *   }
     * })
    **/
    upsert<T extends EnvironmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentUpsertArgs<ExtArgs>>
    ): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentCountArgs} args - Arguments to filter Environments to count.
     * @example
     * // Count the number of Environments
     * const count = await prisma.environment.count({
     *   where: {
     *     // ... the filter for the Environments we want to count
     *   }
     * })
    **/
    count<T extends EnvironmentCountArgs>(
      args?: Subset<T, EnvironmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentAggregateArgs>(args: Subset<T, EnvironmentAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentAggregateType<T>>

    /**
     * Group by Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvironmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvironmentGroupByArgs['orderBy'] }
        : { orderBy?: EnvironmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Environment model
   */
  readonly fields: EnvironmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Environment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvironmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    servers<T extends Environment$serversArgs<ExtArgs> = {}>(args?: Subset<T, Environment$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findMany'> | Null>;

    approvals<T extends Environment$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Environment$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Environment model
   */ 
  interface EnvironmentFieldRefs {
    readonly id: FieldRef<"Environment", 'Int'>
    readonly name: FieldRef<"Environment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Environment findUnique
   */
  export type EnvironmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }


  /**
   * Environment findUniqueOrThrow
   */
  export type EnvironmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }


  /**
   * Environment findFirst
   */
  export type EnvironmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }


  /**
   * Environment findFirstOrThrow
   */
  export type EnvironmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }


  /**
   * Environment findMany
   */
  export type EnvironmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environments to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }


  /**
   * Environment create
   */
  export type EnvironmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Environment.
     */
    data: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
  }


  /**
   * Environment createMany
   */
  export type EnvironmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Environments.
     */
    data: EnvironmentCreateManyInput | EnvironmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Environment update
   */
  export type EnvironmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Environment.
     */
    data: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
    /**
     * Choose, which Environment to update.
     */
    where: EnvironmentWhereUniqueInput
  }


  /**
   * Environment updateMany
   */
  export type EnvironmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Environments.
     */
    data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which Environments to update
     */
    where?: EnvironmentWhereInput
  }


  /**
   * Environment upsert
   */
  export type EnvironmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Environment to update in case it exists.
     */
    where: EnvironmentWhereUniqueInput
    /**
     * In case the Environment found by the `where` argument doesn't exist, create a new Environment with this data.
     */
    create: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
    /**
     * In case the Environment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
  }


  /**
   * Environment delete
   */
  export type EnvironmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter which Environment to delete.
     */
    where: EnvironmentWhereUniqueInput
  }


  /**
   * Environment deleteMany
   */
  export type EnvironmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environments to delete
     */
    where?: EnvironmentWhereInput
  }


  /**
   * Environment.servers
   */
  export type Environment$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    cursor?: ServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * Environment.approvals
   */
  export type Environment$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }


  /**
   * Environment without action
   */
  export type EnvironmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
  }



  /**
   * Model Software
   */

  export type AggregateSoftware = {
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  export type SoftwareAvgAggregateOutputType = {
    id: number | null
  }

  export type SoftwareSumAggregateOutputType = {
    id: number | null
  }

  export type SoftwareMinAggregateOutputType = {
    id: number | null
    name: string | null
    github: string | null
  }

  export type SoftwareMaxAggregateOutputType = {
    id: number | null
    name: string | null
    github: string | null
  }

  export type SoftwareCountAggregateOutputType = {
    id: number
    name: number
    github: number
    _all: number
  }


  export type SoftwareAvgAggregateInputType = {
    id?: true
  }

  export type SoftwareSumAggregateInputType = {
    id?: true
  }

  export type SoftwareMinAggregateInputType = {
    id?: true
    name?: true
    github?: true
  }

  export type SoftwareMaxAggregateInputType = {
    id?: true
    name?: true
    github?: true
  }

  export type SoftwareCountAggregateInputType = {
    id?: true
    name?: true
    github?: true
    _all?: true
  }

  export type SoftwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to aggregate.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Software
    **/
    _count?: true | SoftwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoftwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoftwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwareMaxAggregateInputType
  }

  export type GetSoftwareAggregateType<T extends SoftwareAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftware[P]>
      : GetScalarType<T[P], AggregateSoftware[P]>
  }




  export type SoftwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithAggregationInput | SoftwareOrderByWithAggregationInput[]
    by: SoftwareScalarFieldEnum[] | SoftwareScalarFieldEnum
    having?: SoftwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwareCountAggregateInputType | true
    _avg?: SoftwareAvgAggregateInputType
    _sum?: SoftwareSumAggregateInputType
    _min?: SoftwareMinAggregateInputType
    _max?: SoftwareMaxAggregateInputType
  }

  export type SoftwareGroupByOutputType = {
    id: number
    name: string
    github: string | null
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  type GetSoftwareGroupByPayload<T extends SoftwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
        }
      >
    >


  export type SoftwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    github?: boolean
    approved_version_test?: boolean | Software$approved_version_testArgs<ExtArgs>
    approved_version_main?: boolean | Software$approved_version_mainArgs<ExtArgs>
    newest_version?: boolean | Software$newest_versionArgs<ExtArgs>
    versions?: boolean | Software$versionsArgs<ExtArgs>
    ansible_groups?: boolean | Software$ansible_groupsArgs<ExtArgs>
    _count?: boolean | SoftwareCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["software"]>

  export type SoftwareSelectScalar = {
    id?: boolean
    name?: boolean
    github?: boolean
  }

  export type SoftwareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approved_version_test?: boolean | Software$approved_version_testArgs<ExtArgs>
    approved_version_main?: boolean | Software$approved_version_mainArgs<ExtArgs>
    newest_version?: boolean | Software$newest_versionArgs<ExtArgs>
    versions?: boolean | Software$versionsArgs<ExtArgs>
    ansible_groups?: boolean | Software$ansible_groupsArgs<ExtArgs>
    _count?: boolean | SoftwareCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SoftwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Software"
    objects: {
      approved_version_test: Prisma.$SoftwareVersionPayload<ExtArgs> | null
      approved_version_main: Prisma.$SoftwareVersionPayload<ExtArgs> | null
      newest_version: Prisma.$SoftwareVersionPayload<ExtArgs> | null
      versions: Prisma.$SoftwareVersionPayload<ExtArgs>[]
      ansible_groups: Prisma.$AnsibleGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      github: string | null
    }, ExtArgs["result"]["software"]>
    composites: {}
  }


  type SoftwareGetPayload<S extends boolean | null | undefined | SoftwareDefaultArgs> = $Result.GetResult<Prisma.$SoftwarePayload, S>

  type SoftwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoftwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwareCountAggregateInputType | true
    }

  export interface SoftwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Software'], meta: { name: 'Software' } }
    /**
     * Find zero or one Software that matches the filter.
     * @param {SoftwareFindUniqueArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoftwareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareFindUniqueArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Software that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoftwareFindUniqueOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoftwareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoftwareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindFirstArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Software that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoftwareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Software
     * const software = await prisma.software.findMany()
     * 
     * // Get first 10 Software
     * const software = await prisma.software.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const softwareWithIdOnly = await prisma.software.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SoftwareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Software.
     * @param {SoftwareCreateArgs} args - Arguments to create a Software.
     * @example
     * // Create one Software
     * const Software = await prisma.software.create({
     *   data: {
     *     // ... data to create a Software
     *   }
     * })
     * 
    **/
    create<T extends SoftwareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareCreateArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Software.
     *     @param {SoftwareCreateManyArgs} args - Arguments to create many Software.
     *     @example
     *     // Create many Software
     *     const software = await prisma.software.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoftwareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Software.
     * @param {SoftwareDeleteArgs} args - Arguments to delete one Software.
     * @example
     * // Delete one Software
     * const Software = await prisma.software.delete({
     *   where: {
     *     // ... filter to delete one Software
     *   }
     * })
     * 
    **/
    delete<T extends SoftwareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareDeleteArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Software.
     * @param {SoftwareUpdateArgs} args - Arguments to update one Software.
     * @example
     * // Update one Software
     * const software = await prisma.software.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoftwareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpdateArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Software.
     * @param {SoftwareDeleteManyArgs} args - Arguments to filter Software to delete.
     * @example
     * // Delete a few Software
     * const { count } = await prisma.software.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoftwareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Software
     * const software = await prisma.software.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoftwareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Software.
     * @param {SoftwareUpsertArgs} args - Arguments to update or create a Software.
     * @example
     * // Update or create a Software
     * const software = await prisma.software.upsert({
     *   create: {
     *     // ... data to create a Software
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Software we want to update
     *   }
     * })
    **/
    upsert<T extends SoftwareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpsertArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareCountArgs} args - Arguments to filter Software to count.
     * @example
     * // Count the number of Software
     * const count = await prisma.software.count({
     *   where: {
     *     // ... the filter for the Software we want to count
     *   }
     * })
    **/
    count<T extends SoftwareCountArgs>(
      args?: Subset<T, SoftwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwareAggregateArgs>(args: Subset<T, SoftwareAggregateArgs>): Prisma.PrismaPromise<GetSoftwareAggregateType<T>>

    /**
     * Group by Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoftwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoftwareGroupByArgs['orderBy'] }
        : { orderBy?: SoftwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoftwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Software model
   */
  readonly fields: SoftwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Software.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoftwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    approved_version_test<T extends Software$approved_version_testArgs<ExtArgs> = {}>(args?: Subset<T, Software$approved_version_testArgs<ExtArgs>>): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    approved_version_main<T extends Software$approved_version_mainArgs<ExtArgs> = {}>(args?: Subset<T, Software$approved_version_mainArgs<ExtArgs>>): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    newest_version<T extends Software$newest_versionArgs<ExtArgs> = {}>(args?: Subset<T, Software$newest_versionArgs<ExtArgs>>): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    versions<T extends Software$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Software$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ansible_groups<T extends Software$ansible_groupsArgs<ExtArgs> = {}>(args?: Subset<T, Software$ansible_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnsibleGroupPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Software model
   */ 
  interface SoftwareFieldRefs {
    readonly id: FieldRef<"Software", 'Int'>
    readonly name: FieldRef<"Software", 'String'>
    readonly github: FieldRef<"Software", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Software findUnique
   */
  export type SoftwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software findUniqueOrThrow
   */
  export type SoftwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software findFirst
   */
  export type SoftwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software findFirstOrThrow
   */
  export type SoftwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software findMany
   */
  export type SoftwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software create
   */
  export type SoftwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to create a Software.
     */
    data: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
  }


  /**
   * Software createMany
   */
  export type SoftwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Software.
     */
    data: SoftwareCreateManyInput | SoftwareCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Software update
   */
  export type SoftwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to update a Software.
     */
    data: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
    /**
     * Choose, which Software to update.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software updateMany
   */
  export type SoftwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Software.
     */
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyInput>
    /**
     * Filter which Software to update
     */
    where?: SoftwareWhereInput
  }


  /**
   * Software upsert
   */
  export type SoftwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The filter to search for the Software to update in case it exists.
     */
    where: SoftwareWhereUniqueInput
    /**
     * In case the Software found by the `where` argument doesn't exist, create a new Software with this data.
     */
    create: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
    /**
     * In case the Software was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
  }


  /**
   * Software delete
   */
  export type SoftwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter which Software to delete.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software deleteMany
   */
  export type SoftwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to delete
     */
    where?: SoftwareWhereInput
  }


  /**
   * Software.approved_version_test
   */
  export type Software$approved_version_testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
  }


  /**
   * Software.approved_version_main
   */
  export type Software$approved_version_mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
  }


  /**
   * Software.newest_version
   */
  export type Software$newest_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
  }


  /**
   * Software.versions
   */
  export type Software$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    cursor?: SoftwareVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareVersionScalarFieldEnum | SoftwareVersionScalarFieldEnum[]
  }


  /**
   * Software.ansible_groups
   */
  export type Software$ansible_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnsibleGroup
     */
    select?: AnsibleGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnsibleGroupInclude<ExtArgs> | null
    where?: AnsibleGroupWhereInput
    orderBy?: AnsibleGroupOrderByWithRelationInput | AnsibleGroupOrderByWithRelationInput[]
    cursor?: AnsibleGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnsibleGroupScalarFieldEnum | AnsibleGroupScalarFieldEnum[]
  }


  /**
   * Software without action
   */
  export type SoftwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
  }



  /**
   * Model SoftwareVersion
   */

  export type AggregateSoftwareVersion = {
    _count: SoftwareVersionCountAggregateOutputType | null
    _avg: SoftwareVersionAvgAggregateOutputType | null
    _sum: SoftwareVersionSumAggregateOutputType | null
    _min: SoftwareVersionMinAggregateOutputType | null
    _max: SoftwareVersionMaxAggregateOutputType | null
  }

  export type SoftwareVersionAvgAggregateOutputType = {
    id: number | null
    software_id: number | null
    approved_version_test_Id: number | null
    approved_version_main_Id: number | null
    newest_version_Id: number | null
  }

  export type SoftwareVersionSumAggregateOutputType = {
    id: number | null
    software_id: number | null
    approved_version_test_Id: number | null
    approved_version_main_Id: number | null
    newest_version_Id: number | null
  }

  export type SoftwareVersionMinAggregateOutputType = {
    id: number | null
    name: string | null
    github: string | null
    creator: string | null
    last_editor: string | null
    date_created: Date | null
    last_change: Date | null
    latest_release: string | null
    software_id: number | null
    approved_version_test_Id: number | null
    approved_version_main_Id: number | null
    newest_version_Id: number | null
    approved: boolean | null
  }

  export type SoftwareVersionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    github: string | null
    creator: string | null
    last_editor: string | null
    date_created: Date | null
    last_change: Date | null
    latest_release: string | null
    software_id: number | null
    approved_version_test_Id: number | null
    approved_version_main_Id: number | null
    newest_version_Id: number | null
    approved: boolean | null
  }

  export type SoftwareVersionCountAggregateOutputType = {
    id: number
    name: number
    github: number
    creator: number
    last_editor: number
    date_created: number
    last_change: number
    latest_release: number
    software_id: number
    approved_version_test_Id: number
    approved_version_main_Id: number
    newest_version_Id: number
    approved: number
    _all: number
  }


  export type SoftwareVersionAvgAggregateInputType = {
    id?: true
    software_id?: true
    approved_version_test_Id?: true
    approved_version_main_Id?: true
    newest_version_Id?: true
  }

  export type SoftwareVersionSumAggregateInputType = {
    id?: true
    software_id?: true
    approved_version_test_Id?: true
    approved_version_main_Id?: true
    newest_version_Id?: true
  }

  export type SoftwareVersionMinAggregateInputType = {
    id?: true
    name?: true
    github?: true
    creator?: true
    last_editor?: true
    date_created?: true
    last_change?: true
    latest_release?: true
    software_id?: true
    approved_version_test_Id?: true
    approved_version_main_Id?: true
    newest_version_Id?: true
    approved?: true
  }

  export type SoftwareVersionMaxAggregateInputType = {
    id?: true
    name?: true
    github?: true
    creator?: true
    last_editor?: true
    date_created?: true
    last_change?: true
    latest_release?: true
    software_id?: true
    approved_version_test_Id?: true
    approved_version_main_Id?: true
    newest_version_Id?: true
    approved?: true
  }

  export type SoftwareVersionCountAggregateInputType = {
    id?: true
    name?: true
    github?: true
    creator?: true
    last_editor?: true
    date_created?: true
    last_change?: true
    latest_release?: true
    software_id?: true
    approved_version_test_Id?: true
    approved_version_main_Id?: true
    newest_version_Id?: true
    approved?: true
    _all?: true
  }

  export type SoftwareVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoftwareVersion to aggregate.
     */
    where?: SoftwareVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftwareVersions to fetch.
     */
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoftwareVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftwareVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftwareVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoftwareVersions
    **/
    _count?: true | SoftwareVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoftwareVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoftwareVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwareVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwareVersionMaxAggregateInputType
  }

  export type GetSoftwareVersionAggregateType<T extends SoftwareVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftwareVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftwareVersion[P]>
      : GetScalarType<T[P], AggregateSoftwareVersion[P]>
  }




  export type SoftwareVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareVersionWhereInput
    orderBy?: SoftwareVersionOrderByWithAggregationInput | SoftwareVersionOrderByWithAggregationInput[]
    by: SoftwareVersionScalarFieldEnum[] | SoftwareVersionScalarFieldEnum
    having?: SoftwareVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwareVersionCountAggregateInputType | true
    _avg?: SoftwareVersionAvgAggregateInputType
    _sum?: SoftwareVersionSumAggregateInputType
    _min?: SoftwareVersionMinAggregateInputType
    _max?: SoftwareVersionMaxAggregateInputType
  }

  export type SoftwareVersionGroupByOutputType = {
    id: number
    name: string
    github: string | null
    creator: string | null
    last_editor: string | null
    date_created: Date
    last_change: Date
    latest_release: string | null
    software_id: number | null
    approved_version_test_Id: number | null
    approved_version_main_Id: number | null
    newest_version_Id: number | null
    approved: boolean | null
    _count: SoftwareVersionCountAggregateOutputType | null
    _avg: SoftwareVersionAvgAggregateOutputType | null
    _sum: SoftwareVersionSumAggregateOutputType | null
    _min: SoftwareVersionMinAggregateOutputType | null
    _max: SoftwareVersionMaxAggregateOutputType | null
  }

  type GetSoftwareVersionGroupByPayload<T extends SoftwareVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwareVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwareVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwareVersionGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwareVersionGroupByOutputType[P]>
        }
      >
    >


  export type SoftwareVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    github?: boolean
    creator?: boolean
    last_editor?: boolean
    date_created?: boolean
    last_change?: boolean
    latest_release?: boolean
    software_id?: boolean
    approved_version_test_Id?: boolean
    approved_version_main_Id?: boolean
    newest_version_Id?: boolean
    approved?: boolean
    software?: boolean | SoftwareVersion$softwareArgs<ExtArgs>
    approved_version_test?: boolean | SoftwareVersion$approved_version_testArgs<ExtArgs>
    approved_version_main?: boolean | SoftwareVersion$approved_version_mainArgs<ExtArgs>
    newest_version?: boolean | SoftwareVersion$newest_versionArgs<ExtArgs>
    servers?: boolean | SoftwareVersion$serversArgs<ExtArgs>
    approvals?: boolean | SoftwareVersion$approvalsArgs<ExtArgs>
    _count?: boolean | SoftwareVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["softwareVersion"]>

  export type SoftwareVersionSelectScalar = {
    id?: boolean
    name?: boolean
    github?: boolean
    creator?: boolean
    last_editor?: boolean
    date_created?: boolean
    last_change?: boolean
    latest_release?: boolean
    software_id?: boolean
    approved_version_test_Id?: boolean
    approved_version_main_Id?: boolean
    newest_version_Id?: boolean
    approved?: boolean
  }

  export type SoftwareVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    software?: boolean | SoftwareVersion$softwareArgs<ExtArgs>
    approved_version_test?: boolean | SoftwareVersion$approved_version_testArgs<ExtArgs>
    approved_version_main?: boolean | SoftwareVersion$approved_version_mainArgs<ExtArgs>
    newest_version?: boolean | SoftwareVersion$newest_versionArgs<ExtArgs>
    servers?: boolean | SoftwareVersion$serversArgs<ExtArgs>
    approvals?: boolean | SoftwareVersion$approvalsArgs<ExtArgs>
    _count?: boolean | SoftwareVersionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SoftwareVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoftwareVersion"
    objects: {
      software: Prisma.$SoftwarePayload<ExtArgs> | null
      approved_version_test: Prisma.$SoftwarePayload<ExtArgs> | null
      approved_version_main: Prisma.$SoftwarePayload<ExtArgs> | null
      newest_version: Prisma.$SoftwarePayload<ExtArgs> | null
      servers: Prisma.$ServerPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      github: string | null
      creator: string | null
      last_editor: string | null
      date_created: Date
      last_change: Date
      latest_release: string | null
      software_id: number | null
      approved_version_test_Id: number | null
      approved_version_main_Id: number | null
      newest_version_Id: number | null
      approved: boolean | null
    }, ExtArgs["result"]["softwareVersion"]>
    composites: {}
  }


  type SoftwareVersionGetPayload<S extends boolean | null | undefined | SoftwareVersionDefaultArgs> = $Result.GetResult<Prisma.$SoftwareVersionPayload, S>

  type SoftwareVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoftwareVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwareVersionCountAggregateInputType | true
    }

  export interface SoftwareVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoftwareVersion'], meta: { name: 'SoftwareVersion' } }
    /**
     * Find zero or one SoftwareVersion that matches the filter.
     * @param {SoftwareVersionFindUniqueArgs} args - Arguments to find a SoftwareVersion
     * @example
     * // Get one SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoftwareVersionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionFindUniqueArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SoftwareVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoftwareVersionFindUniqueOrThrowArgs} args - Arguments to find a SoftwareVersion
     * @example
     * // Get one SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoftwareVersionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SoftwareVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionFindFirstArgs} args - Arguments to find a SoftwareVersion
     * @example
     * // Get one SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoftwareVersionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionFindFirstArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SoftwareVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionFindFirstOrThrowArgs} args - Arguments to find a SoftwareVersion
     * @example
     * // Get one SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoftwareVersionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SoftwareVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoftwareVersions
     * const softwareVersions = await prisma.softwareVersion.findMany()
     * 
     * // Get first 10 SoftwareVersions
     * const softwareVersions = await prisma.softwareVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const softwareVersionWithIdOnly = await prisma.softwareVersion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SoftwareVersionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SoftwareVersion.
     * @param {SoftwareVersionCreateArgs} args - Arguments to create a SoftwareVersion.
     * @example
     * // Create one SoftwareVersion
     * const SoftwareVersion = await prisma.softwareVersion.create({
     *   data: {
     *     // ... data to create a SoftwareVersion
     *   }
     * })
     * 
    **/
    create<T extends SoftwareVersionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionCreateArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SoftwareVersions.
     *     @param {SoftwareVersionCreateManyArgs} args - Arguments to create many SoftwareVersions.
     *     @example
     *     // Create many SoftwareVersions
     *     const softwareVersion = await prisma.softwareVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoftwareVersionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SoftwareVersion.
     * @param {SoftwareVersionDeleteArgs} args - Arguments to delete one SoftwareVersion.
     * @example
     * // Delete one SoftwareVersion
     * const SoftwareVersion = await prisma.softwareVersion.delete({
     *   where: {
     *     // ... filter to delete one SoftwareVersion
     *   }
     * })
     * 
    **/
    delete<T extends SoftwareVersionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionDeleteArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SoftwareVersion.
     * @param {SoftwareVersionUpdateArgs} args - Arguments to update one SoftwareVersion.
     * @example
     * // Update one SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoftwareVersionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionUpdateArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SoftwareVersions.
     * @param {SoftwareVersionDeleteManyArgs} args - Arguments to filter SoftwareVersions to delete.
     * @example
     * // Delete a few SoftwareVersions
     * const { count } = await prisma.softwareVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoftwareVersionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareVersionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoftwareVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoftwareVersions
     * const softwareVersion = await prisma.softwareVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoftwareVersionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SoftwareVersion.
     * @param {SoftwareVersionUpsertArgs} args - Arguments to update or create a SoftwareVersion.
     * @example
     * // Update or create a SoftwareVersion
     * const softwareVersion = await prisma.softwareVersion.upsert({
     *   create: {
     *     // ... data to create a SoftwareVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoftwareVersion we want to update
     *   }
     * })
    **/
    upsert<T extends SoftwareVersionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareVersionUpsertArgs<ExtArgs>>
    ): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SoftwareVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionCountArgs} args - Arguments to filter SoftwareVersions to count.
     * @example
     * // Count the number of SoftwareVersions
     * const count = await prisma.softwareVersion.count({
     *   where: {
     *     // ... the filter for the SoftwareVersions we want to count
     *   }
     * })
    **/
    count<T extends SoftwareVersionCountArgs>(
      args?: Subset<T, SoftwareVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwareVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoftwareVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwareVersionAggregateArgs>(args: Subset<T, SoftwareVersionAggregateArgs>): Prisma.PrismaPromise<GetSoftwareVersionAggregateType<T>>

    /**
     * Group by SoftwareVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoftwareVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoftwareVersionGroupByArgs['orderBy'] }
        : { orderBy?: SoftwareVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoftwareVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwareVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoftwareVersion model
   */
  readonly fields: SoftwareVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoftwareVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoftwareVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    software<T extends SoftwareVersion$softwareArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$softwareArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    approved_version_test<T extends SoftwareVersion$approved_version_testArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$approved_version_testArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    approved_version_main<T extends SoftwareVersion$approved_version_mainArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$approved_version_mainArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    newest_version<T extends SoftwareVersion$newest_versionArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$newest_versionArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    servers<T extends SoftwareVersion$serversArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, 'findMany'> | Null>;

    approvals<T extends SoftwareVersion$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, SoftwareVersion$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SoftwareVersion model
   */ 
  interface SoftwareVersionFieldRefs {
    readonly id: FieldRef<"SoftwareVersion", 'Int'>
    readonly name: FieldRef<"SoftwareVersion", 'String'>
    readonly github: FieldRef<"SoftwareVersion", 'String'>
    readonly creator: FieldRef<"SoftwareVersion", 'String'>
    readonly last_editor: FieldRef<"SoftwareVersion", 'String'>
    readonly date_created: FieldRef<"SoftwareVersion", 'DateTime'>
    readonly last_change: FieldRef<"SoftwareVersion", 'DateTime'>
    readonly latest_release: FieldRef<"SoftwareVersion", 'String'>
    readonly software_id: FieldRef<"SoftwareVersion", 'Int'>
    readonly approved_version_test_Id: FieldRef<"SoftwareVersion", 'Int'>
    readonly approved_version_main_Id: FieldRef<"SoftwareVersion", 'Int'>
    readonly newest_version_Id: FieldRef<"SoftwareVersion", 'Int'>
    readonly approved: FieldRef<"SoftwareVersion", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * SoftwareVersion findUnique
   */
  export type SoftwareVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter, which SoftwareVersion to fetch.
     */
    where: SoftwareVersionWhereUniqueInput
  }


  /**
   * SoftwareVersion findUniqueOrThrow
   */
  export type SoftwareVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter, which SoftwareVersion to fetch.
     */
    where: SoftwareVersionWhereUniqueInput
  }


  /**
   * SoftwareVersion findFirst
   */
  export type SoftwareVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter, which SoftwareVersion to fetch.
     */
    where?: SoftwareVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftwareVersions to fetch.
     */
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoftwareVersions.
     */
    cursor?: SoftwareVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftwareVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftwareVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoftwareVersions.
     */
    distinct?: SoftwareVersionScalarFieldEnum | SoftwareVersionScalarFieldEnum[]
  }


  /**
   * SoftwareVersion findFirstOrThrow
   */
  export type SoftwareVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter, which SoftwareVersion to fetch.
     */
    where?: SoftwareVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftwareVersions to fetch.
     */
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoftwareVersions.
     */
    cursor?: SoftwareVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftwareVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftwareVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoftwareVersions.
     */
    distinct?: SoftwareVersionScalarFieldEnum | SoftwareVersionScalarFieldEnum[]
  }


  /**
   * SoftwareVersion findMany
   */
  export type SoftwareVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter, which SoftwareVersions to fetch.
     */
    where?: SoftwareVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftwareVersions to fetch.
     */
    orderBy?: SoftwareVersionOrderByWithRelationInput | SoftwareVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoftwareVersions.
     */
    cursor?: SoftwareVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftwareVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftwareVersions.
     */
    skip?: number
    distinct?: SoftwareVersionScalarFieldEnum | SoftwareVersionScalarFieldEnum[]
  }


  /**
   * SoftwareVersion create
   */
  export type SoftwareVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a SoftwareVersion.
     */
    data: XOR<SoftwareVersionCreateInput, SoftwareVersionUncheckedCreateInput>
  }


  /**
   * SoftwareVersion createMany
   */
  export type SoftwareVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoftwareVersions.
     */
    data: SoftwareVersionCreateManyInput | SoftwareVersionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SoftwareVersion update
   */
  export type SoftwareVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a SoftwareVersion.
     */
    data: XOR<SoftwareVersionUpdateInput, SoftwareVersionUncheckedUpdateInput>
    /**
     * Choose, which SoftwareVersion to update.
     */
    where: SoftwareVersionWhereUniqueInput
  }


  /**
   * SoftwareVersion updateMany
   */
  export type SoftwareVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoftwareVersions.
     */
    data: XOR<SoftwareVersionUpdateManyMutationInput, SoftwareVersionUncheckedUpdateManyInput>
    /**
     * Filter which SoftwareVersions to update
     */
    where?: SoftwareVersionWhereInput
  }


  /**
   * SoftwareVersion upsert
   */
  export type SoftwareVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the SoftwareVersion to update in case it exists.
     */
    where: SoftwareVersionWhereUniqueInput
    /**
     * In case the SoftwareVersion found by the `where` argument doesn't exist, create a new SoftwareVersion with this data.
     */
    create: XOR<SoftwareVersionCreateInput, SoftwareVersionUncheckedCreateInput>
    /**
     * In case the SoftwareVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoftwareVersionUpdateInput, SoftwareVersionUncheckedUpdateInput>
  }


  /**
   * SoftwareVersion delete
   */
  export type SoftwareVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    /**
     * Filter which SoftwareVersion to delete.
     */
    where: SoftwareVersionWhereUniqueInput
  }


  /**
   * SoftwareVersion deleteMany
   */
  export type SoftwareVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoftwareVersions to delete
     */
    where?: SoftwareVersionWhereInput
  }


  /**
   * SoftwareVersion.software
   */
  export type SoftwareVersion$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
  }


  /**
   * SoftwareVersion.approved_version_test
   */
  export type SoftwareVersion$approved_version_testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
  }


  /**
   * SoftwareVersion.approved_version_main
   */
  export type SoftwareVersion$approved_version_mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
  }


  /**
   * SoftwareVersion.newest_version
   */
  export type SoftwareVersion$newest_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
  }


  /**
   * SoftwareVersion.servers
   */
  export type SoftwareVersion$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServerInclude<ExtArgs> | null
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    cursor?: ServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }


  /**
   * SoftwareVersion.approvals
   */
  export type SoftwareVersion$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }


  /**
   * SoftwareVersion without action
   */
  export type SoftwareVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
  }



  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalAvgAggregateOutputType = {
    id: number | null
    environment_id: number | null
    software_version_id: number | null
  }

  export type ApprovalSumAggregateOutputType = {
    id: number | null
    environment_id: number | null
    software_version_id: number | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: number | null
    approver: string | null
    date: Date | null
    environment_id: number | null
    software_version_id: number | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: number | null
    approver: string | null
    date: Date | null
    environment_id: number | null
    software_version_id: number | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    approver: number
    date: number
    environment_id: number
    software_version_id: number
    _all: number
  }


  export type ApprovalAvgAggregateInputType = {
    id?: true
    environment_id?: true
    software_version_id?: true
  }

  export type ApprovalSumAggregateInputType = {
    id?: true
    environment_id?: true
    software_version_id?: true
  }

  export type ApprovalMinAggregateInputType = {
    id?: true
    approver?: true
    date?: true
    environment_id?: true
    software_version_id?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    approver?: true
    date?: true
    environment_id?: true
    software_version_id?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    approver?: true
    date?: true
    environment_id?: true
    software_version_id?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _avg?: ApprovalAvgAggregateInputType
    _sum?: ApprovalSumAggregateInputType
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: number
    approver: string | null
    date: Date
    environment_id: number
    software_version_id: number | null
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approver?: boolean
    date?: boolean
    environment_id?: boolean
    software_version_id?: boolean
    environment?: boolean | Approval$environmentArgs<ExtArgs>
    software_version?: boolean | Approval$software_versionArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    approver?: boolean
    date?: boolean
    environment_id?: boolean
    software_version_id?: boolean
  }

  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | Approval$environmentArgs<ExtArgs>
    software_version?: boolean | Approval$software_versionArgs<ExtArgs>
  }


  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      environment: Prisma.$EnvironmentPayload<ExtArgs> | null
      software_version: Prisma.$SoftwareVersionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      approver: string | null
      date: Date
      environment_id: number
      software_version_id: number | null
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }


  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApprovalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Approval that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApprovalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApprovalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
    **/
    create<T extends ApprovalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Approvals.
     *     @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     *     @example
     *     // Create many Approvals
     *     const approval = await prisma.approval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApprovalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
    **/
    delete<T extends ApprovalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApprovalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApprovalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApprovalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
    **/
    upsert<T extends ApprovalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>
    ): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    environment<T extends Approval$environmentArgs<ExtArgs> = {}>(args?: Subset<T, Approval$environmentArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    software_version<T extends Approval$software_versionArgs<ExtArgs> = {}>(args?: Subset<T, Approval$software_versionArgs<ExtArgs>>): Prisma__SoftwareVersionClient<$Result.GetResult<Prisma.$SoftwareVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Approval model
   */ 
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'Int'>
    readonly approver: FieldRef<"Approval", 'String'>
    readonly date: FieldRef<"Approval", 'DateTime'>
    readonly environment_id: FieldRef<"Approval", 'Int'>
    readonly software_version_id: FieldRef<"Approval", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }


  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }


  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }


  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }


  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
  }


  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }


  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
  }


  /**
   * Approval.environment
   */
  export type Approval$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentInclude<ExtArgs> | null
    where?: EnvironmentWhereInput
  }


  /**
   * Approval.software_version
   */
  export type Approval$software_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftwareVersion
     */
    select?: SoftwareVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareVersionInclude<ExtArgs> | null
    where?: SoftwareVersionWhereInput
  }


  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApprovalInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EcosystemScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EcosystemScalarFieldEnum = (typeof EcosystemScalarFieldEnum)[keyof typeof EcosystemScalarFieldEnum]


  export const AnsibleGroupScalarFieldEnum: {
    id: 'id',
    group_name: 'group_name',
    ecosystem_id: 'ecosystem_id'
  };

  export type AnsibleGroupScalarFieldEnum = (typeof AnsibleGroupScalarFieldEnum)[keyof typeof AnsibleGroupScalarFieldEnum]


  export const ServerScalarFieldEnum: {
    id: 'id',
    hostname: 'hostname',
    ansible_group_id: 'ansible_group_id',
    date_created: 'date_created',
    date_changed: 'date_changed',
    environment_id: 'environment_id'
  };

  export type ServerScalarFieldEnum = (typeof ServerScalarFieldEnum)[keyof typeof ServerScalarFieldEnum]


  export const EnvironmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


  export const SoftwareScalarFieldEnum: {
    id: 'id',
    name: 'name',
    github: 'github'
  };

  export type SoftwareScalarFieldEnum = (typeof SoftwareScalarFieldEnum)[keyof typeof SoftwareScalarFieldEnum]


  export const SoftwareVersionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    github: 'github',
    creator: 'creator',
    last_editor: 'last_editor',
    date_created: 'date_created',
    last_change: 'last_change',
    latest_release: 'latest_release',
    software_id: 'software_id',
    approved_version_test_Id: 'approved_version_test_Id',
    approved_version_main_Id: 'approved_version_main_Id',
    newest_version_Id: 'newest_version_Id',
    approved: 'approved'
  };

  export type SoftwareVersionScalarFieldEnum = (typeof SoftwareVersionScalarFieldEnum)[keyof typeof SoftwareVersionScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    approver: 'approver',
    date: 'date',
    environment_id: 'environment_id',
    software_version_id: 'software_version_id'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type EcosystemWhereInput = {
    AND?: EcosystemWhereInput | EcosystemWhereInput[]
    OR?: EcosystemWhereInput[]
    NOT?: EcosystemWhereInput | EcosystemWhereInput[]
    id?: IntFilter<"Ecosystem"> | number
    name?: StringFilter<"Ecosystem"> | string
    groups?: AnsibleGroupListRelationFilter
  }

  export type EcosystemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    groups?: AnsibleGroupOrderByRelationAggregateInput
  }

  export type EcosystemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: EcosystemWhereInput | EcosystemWhereInput[]
    OR?: EcosystemWhereInput[]
    NOT?: EcosystemWhereInput | EcosystemWhereInput[]
    groups?: AnsibleGroupListRelationFilter
  }, "id" | "name">

  export type EcosystemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: EcosystemCountOrderByAggregateInput
    _avg?: EcosystemAvgOrderByAggregateInput
    _max?: EcosystemMaxOrderByAggregateInput
    _min?: EcosystemMinOrderByAggregateInput
    _sum?: EcosystemSumOrderByAggregateInput
  }

  export type EcosystemScalarWhereWithAggregatesInput = {
    AND?: EcosystemScalarWhereWithAggregatesInput | EcosystemScalarWhereWithAggregatesInput[]
    OR?: EcosystemScalarWhereWithAggregatesInput[]
    NOT?: EcosystemScalarWhereWithAggregatesInput | EcosystemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ecosystem"> | number
    name?: StringWithAggregatesFilter<"Ecosystem"> | string
  }

  export type AnsibleGroupWhereInput = {
    AND?: AnsibleGroupWhereInput | AnsibleGroupWhereInput[]
    OR?: AnsibleGroupWhereInput[]
    NOT?: AnsibleGroupWhereInput | AnsibleGroupWhereInput[]
    id?: IntFilter<"AnsibleGroup"> | number
    group_name?: StringNullableFilter<"AnsibleGroup"> | string | null
    ecosystem_id?: IntFilter<"AnsibleGroup"> | number
    ecosystem?: XOR<EcosystemNullableRelationFilter, EcosystemWhereInput> | null
    servers?: ServerListRelationFilter
    softwares?: SoftwareListRelationFilter
  }

  export type AnsibleGroupOrderByWithRelationInput = {
    id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    ecosystem_id?: SortOrder
    ecosystem?: EcosystemOrderByWithRelationInput
    servers?: ServerOrderByRelationAggregateInput
    softwares?: SoftwareOrderByRelationAggregateInput
  }

  export type AnsibleGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group_name?: string
    AND?: AnsibleGroupWhereInput | AnsibleGroupWhereInput[]
    OR?: AnsibleGroupWhereInput[]
    NOT?: AnsibleGroupWhereInput | AnsibleGroupWhereInput[]
    ecosystem_id?: IntFilter<"AnsibleGroup"> | number
    ecosystem?: XOR<EcosystemNullableRelationFilter, EcosystemWhereInput> | null
    servers?: ServerListRelationFilter
    softwares?: SoftwareListRelationFilter
  }, "id" | "group_name">

  export type AnsibleGroupOrderByWithAggregationInput = {
    id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    ecosystem_id?: SortOrder
    _count?: AnsibleGroupCountOrderByAggregateInput
    _avg?: AnsibleGroupAvgOrderByAggregateInput
    _max?: AnsibleGroupMaxOrderByAggregateInput
    _min?: AnsibleGroupMinOrderByAggregateInput
    _sum?: AnsibleGroupSumOrderByAggregateInput
  }

  export type AnsibleGroupScalarWhereWithAggregatesInput = {
    AND?: AnsibleGroupScalarWhereWithAggregatesInput | AnsibleGroupScalarWhereWithAggregatesInput[]
    OR?: AnsibleGroupScalarWhereWithAggregatesInput[]
    NOT?: AnsibleGroupScalarWhereWithAggregatesInput | AnsibleGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnsibleGroup"> | number
    group_name?: StringNullableWithAggregatesFilter<"AnsibleGroup"> | string | null
    ecosystem_id?: IntWithAggregatesFilter<"AnsibleGroup"> | number
  }

  export type ServerWhereInput = {
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    id?: IntFilter<"Server"> | number
    hostname?: StringFilter<"Server"> | string
    ansible_group_id?: IntNullableFilter<"Server"> | number | null
    date_created?: DateTimeFilter<"Server"> | Date | string
    date_changed?: DateTimeFilter<"Server"> | Date | string
    environment_id?: IntNullableFilter<"Server"> | number | null
    ansible_group?: XOR<AnsibleGroupNullableRelationFilter, AnsibleGroupWhereInput> | null
    environment?: XOR<EnvironmentNullableRelationFilter, EnvironmentWhereInput> | null
    softwares?: SoftwareVersionListRelationFilter
  }

  export type ServerOrderByWithRelationInput = {
    id?: SortOrder
    hostname?: SortOrder
    ansible_group_id?: SortOrderInput | SortOrder
    date_created?: SortOrder
    date_changed?: SortOrder
    environment_id?: SortOrderInput | SortOrder
    ansible_group?: AnsibleGroupOrderByWithRelationInput
    environment?: EnvironmentOrderByWithRelationInput
    softwares?: SoftwareVersionOrderByRelationAggregateInput
  }

  export type ServerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hostname?: string
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    ansible_group_id?: IntNullableFilter<"Server"> | number | null
    date_created?: DateTimeFilter<"Server"> | Date | string
    date_changed?: DateTimeFilter<"Server"> | Date | string
    environment_id?: IntNullableFilter<"Server"> | number | null
    ansible_group?: XOR<AnsibleGroupNullableRelationFilter, AnsibleGroupWhereInput> | null
    environment?: XOR<EnvironmentNullableRelationFilter, EnvironmentWhereInput> | null
    softwares?: SoftwareVersionListRelationFilter
  }, "id" | "hostname">

  export type ServerOrderByWithAggregationInput = {
    id?: SortOrder
    hostname?: SortOrder
    ansible_group_id?: SortOrderInput | SortOrder
    date_created?: SortOrder
    date_changed?: SortOrder
    environment_id?: SortOrderInput | SortOrder
    _count?: ServerCountOrderByAggregateInput
    _avg?: ServerAvgOrderByAggregateInput
    _max?: ServerMaxOrderByAggregateInput
    _min?: ServerMinOrderByAggregateInput
    _sum?: ServerSumOrderByAggregateInput
  }

  export type ServerScalarWhereWithAggregatesInput = {
    AND?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    OR?: ServerScalarWhereWithAggregatesInput[]
    NOT?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Server"> | number
    hostname?: StringWithAggregatesFilter<"Server"> | string
    ansible_group_id?: IntNullableWithAggregatesFilter<"Server"> | number | null
    date_created?: DateTimeWithAggregatesFilter<"Server"> | Date | string
    date_changed?: DateTimeWithAggregatesFilter<"Server"> | Date | string
    environment_id?: IntNullableWithAggregatesFilter<"Server"> | number | null
  }

  export type EnvironmentWhereInput = {
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    id?: IntFilter<"Environment"> | number
    name?: StringFilter<"Environment"> | string
    servers?: ServerListRelationFilter
    approvals?: ApprovalListRelationFilter
  }

  export type EnvironmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    servers?: ServerOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
  }

  export type EnvironmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    servers?: ServerListRelationFilter
    approvals?: ApprovalListRelationFilter
  }, "id" | "name">

  export type EnvironmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: EnvironmentCountOrderByAggregateInput
    _avg?: EnvironmentAvgOrderByAggregateInput
    _max?: EnvironmentMaxOrderByAggregateInput
    _min?: EnvironmentMinOrderByAggregateInput
    _sum?: EnvironmentSumOrderByAggregateInput
  }

  export type EnvironmentScalarWhereWithAggregatesInput = {
    AND?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    OR?: EnvironmentScalarWhereWithAggregatesInput[]
    NOT?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Environment"> | number
    name?: StringWithAggregatesFilter<"Environment"> | string
  }

  export type SoftwareWhereInput = {
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    id?: IntFilter<"Software"> | number
    name?: StringFilter<"Software"> | string
    github?: StringNullableFilter<"Software"> | string | null
    approved_version_test?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    approved_version_main?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    newest_version?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    versions?: SoftwareVersionListRelationFilter
    ansible_groups?: AnsibleGroupListRelationFilter
  }

  export type SoftwareOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrderInput | SortOrder
    approved_version_test?: SoftwareVersionOrderByWithRelationInput
    approved_version_main?: SoftwareVersionOrderByWithRelationInput
    newest_version?: SoftwareVersionOrderByWithRelationInput
    versions?: SoftwareVersionOrderByRelationAggregateInput
    ansible_groups?: AnsibleGroupOrderByRelationAggregateInput
  }

  export type SoftwareWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    name?: StringFilter<"Software"> | string
    github?: StringNullableFilter<"Software"> | string | null
    approved_version_test?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    approved_version_main?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    newest_version?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
    versions?: SoftwareVersionListRelationFilter
    ansible_groups?: AnsibleGroupListRelationFilter
  }, "id">

  export type SoftwareOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrderInput | SortOrder
    _count?: SoftwareCountOrderByAggregateInput
    _avg?: SoftwareAvgOrderByAggregateInput
    _max?: SoftwareMaxOrderByAggregateInput
    _min?: SoftwareMinOrderByAggregateInput
    _sum?: SoftwareSumOrderByAggregateInput
  }

  export type SoftwareScalarWhereWithAggregatesInput = {
    AND?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    OR?: SoftwareScalarWhereWithAggregatesInput[]
    NOT?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Software"> | number
    name?: StringWithAggregatesFilter<"Software"> | string
    github?: StringNullableWithAggregatesFilter<"Software"> | string | null
  }

  export type SoftwareVersionWhereInput = {
    AND?: SoftwareVersionWhereInput | SoftwareVersionWhereInput[]
    OR?: SoftwareVersionWhereInput[]
    NOT?: SoftwareVersionWhereInput | SoftwareVersionWhereInput[]
    id?: IntFilter<"SoftwareVersion"> | number
    name?: StringFilter<"SoftwareVersion"> | string
    github?: StringNullableFilter<"SoftwareVersion"> | string | null
    creator?: StringNullableFilter<"SoftwareVersion"> | string | null
    last_editor?: StringNullableFilter<"SoftwareVersion"> | string | null
    date_created?: DateTimeFilter<"SoftwareVersion"> | Date | string
    last_change?: DateTimeFilter<"SoftwareVersion"> | Date | string
    latest_release?: StringNullableFilter<"SoftwareVersion"> | string | null
    software_id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved_version_test_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved_version_main_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    newest_version_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved?: BoolNullableFilter<"SoftwareVersion"> | boolean | null
    software?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    approved_version_test?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    approved_version_main?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    newest_version?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    servers?: ServerListRelationFilter
    approvals?: ApprovalListRelationFilter
  }

  export type SoftwareVersionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrderInput | SortOrder
    creator?: SortOrderInput | SortOrder
    last_editor?: SortOrderInput | SortOrder
    date_created?: SortOrder
    last_change?: SortOrder
    latest_release?: SortOrderInput | SortOrder
    software_id?: SortOrderInput | SortOrder
    approved_version_test_Id?: SortOrderInput | SortOrder
    approved_version_main_Id?: SortOrderInput | SortOrder
    newest_version_Id?: SortOrderInput | SortOrder
    approved?: SortOrderInput | SortOrder
    software?: SoftwareOrderByWithRelationInput
    approved_version_test?: SoftwareOrderByWithRelationInput
    approved_version_main?: SoftwareOrderByWithRelationInput
    newest_version?: SoftwareOrderByWithRelationInput
    servers?: ServerOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
  }

  export type SoftwareVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    approved_version_test_Id?: number
    approved_version_main_Id?: number
    newest_version_Id?: number
    AND?: SoftwareVersionWhereInput | SoftwareVersionWhereInput[]
    OR?: SoftwareVersionWhereInput[]
    NOT?: SoftwareVersionWhereInput | SoftwareVersionWhereInput[]
    name?: StringFilter<"SoftwareVersion"> | string
    github?: StringNullableFilter<"SoftwareVersion"> | string | null
    creator?: StringNullableFilter<"SoftwareVersion"> | string | null
    last_editor?: StringNullableFilter<"SoftwareVersion"> | string | null
    date_created?: DateTimeFilter<"SoftwareVersion"> | Date | string
    last_change?: DateTimeFilter<"SoftwareVersion"> | Date | string
    latest_release?: StringNullableFilter<"SoftwareVersion"> | string | null
    software_id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved?: BoolNullableFilter<"SoftwareVersion"> | boolean | null
    software?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    approved_version_test?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    approved_version_main?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    newest_version?: XOR<SoftwareNullableRelationFilter, SoftwareWhereInput> | null
    servers?: ServerListRelationFilter
    approvals?: ApprovalListRelationFilter
  }, "id" | "approved_version_test_Id" | "approved_version_main_Id" | "newest_version_Id">

  export type SoftwareVersionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrderInput | SortOrder
    creator?: SortOrderInput | SortOrder
    last_editor?: SortOrderInput | SortOrder
    date_created?: SortOrder
    last_change?: SortOrder
    latest_release?: SortOrderInput | SortOrder
    software_id?: SortOrderInput | SortOrder
    approved_version_test_Id?: SortOrderInput | SortOrder
    approved_version_main_Id?: SortOrderInput | SortOrder
    newest_version_Id?: SortOrderInput | SortOrder
    approved?: SortOrderInput | SortOrder
    _count?: SoftwareVersionCountOrderByAggregateInput
    _avg?: SoftwareVersionAvgOrderByAggregateInput
    _max?: SoftwareVersionMaxOrderByAggregateInput
    _min?: SoftwareVersionMinOrderByAggregateInput
    _sum?: SoftwareVersionSumOrderByAggregateInput
  }

  export type SoftwareVersionScalarWhereWithAggregatesInput = {
    AND?: SoftwareVersionScalarWhereWithAggregatesInput | SoftwareVersionScalarWhereWithAggregatesInput[]
    OR?: SoftwareVersionScalarWhereWithAggregatesInput[]
    NOT?: SoftwareVersionScalarWhereWithAggregatesInput | SoftwareVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SoftwareVersion"> | number
    name?: StringWithAggregatesFilter<"SoftwareVersion"> | string
    github?: StringNullableWithAggregatesFilter<"SoftwareVersion"> | string | null
    creator?: StringNullableWithAggregatesFilter<"SoftwareVersion"> | string | null
    last_editor?: StringNullableWithAggregatesFilter<"SoftwareVersion"> | string | null
    date_created?: DateTimeWithAggregatesFilter<"SoftwareVersion"> | Date | string
    last_change?: DateTimeWithAggregatesFilter<"SoftwareVersion"> | Date | string
    latest_release?: StringNullableWithAggregatesFilter<"SoftwareVersion"> | string | null
    software_id?: IntNullableWithAggregatesFilter<"SoftwareVersion"> | number | null
    approved_version_test_Id?: IntNullableWithAggregatesFilter<"SoftwareVersion"> | number | null
    approved_version_main_Id?: IntNullableWithAggregatesFilter<"SoftwareVersion"> | number | null
    newest_version_Id?: IntNullableWithAggregatesFilter<"SoftwareVersion"> | number | null
    approved?: BoolNullableWithAggregatesFilter<"SoftwareVersion"> | boolean | null
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: IntFilter<"Approval"> | number
    approver?: StringNullableFilter<"Approval"> | string | null
    date?: DateTimeFilter<"Approval"> | Date | string
    environment_id?: IntFilter<"Approval"> | number
    software_version_id?: IntNullableFilter<"Approval"> | number | null
    environment?: XOR<EnvironmentNullableRelationFilter, EnvironmentWhereInput> | null
    software_version?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    approver?: SortOrderInput | SortOrder
    date?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrderInput | SortOrder
    environment?: EnvironmentOrderByWithRelationInput
    software_version?: SoftwareVersionOrderByWithRelationInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    approver?: StringNullableFilter<"Approval"> | string | null
    date?: DateTimeFilter<"Approval"> | Date | string
    environment_id?: IntFilter<"Approval"> | number
    software_version_id?: IntNullableFilter<"Approval"> | number | null
    environment?: XOR<EnvironmentNullableRelationFilter, EnvironmentWhereInput> | null
    software_version?: XOR<SoftwareVersionNullableRelationFilter, SoftwareVersionWhereInput> | null
  }, "id">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    approver?: SortOrderInput | SortOrder
    date?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrderInput | SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _avg?: ApprovalAvgOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
    _sum?: ApprovalSumOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Approval"> | number
    approver?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    date?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
    environment_id?: IntWithAggregatesFilter<"Approval"> | number
    software_version_id?: IntNullableWithAggregatesFilter<"Approval"> | number | null
  }

  export type EcosystemCreateInput = {
    name: string
    groups?: AnsibleGroupCreateNestedManyWithoutEcosystemInput
  }

  export type EcosystemUncheckedCreateInput = {
    id?: number
    name: string
    groups?: AnsibleGroupUncheckedCreateNestedManyWithoutEcosystemInput
  }

  export type EcosystemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    groups?: AnsibleGroupUpdateManyWithoutEcosystemNestedInput
  }

  export type EcosystemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    groups?: AnsibleGroupUncheckedUpdateManyWithoutEcosystemNestedInput
  }

  export type EcosystemCreateManyInput = {
    id?: number
    name: string
  }

  export type EcosystemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EcosystemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnsibleGroupCreateInput = {
    group_name?: string | null
    ecosystem?: EcosystemCreateNestedOneWithoutGroupsInput
    servers?: ServerCreateNestedManyWithoutAnsible_groupInput
    softwares?: SoftwareCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupUncheckedCreateInput = {
    id?: number
    group_name?: string | null
    ecosystem_id: number
    servers?: ServerUncheckedCreateNestedManyWithoutAnsible_groupInput
    softwares?: SoftwareUncheckedCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupUpdateInput = {
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem?: EcosystemUpdateOneWithoutGroupsNestedInput
    servers?: ServerUpdateManyWithoutAnsible_groupNestedInput
    softwares?: SoftwareUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type AnsibleGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem_id?: IntFieldUpdateOperationsInput | number
    servers?: ServerUncheckedUpdateManyWithoutAnsible_groupNestedInput
    softwares?: SoftwareUncheckedUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type AnsibleGroupCreateManyInput = {
    id?: number
    group_name?: string | null
    ecosystem_id: number
  }

  export type AnsibleGroupUpdateManyMutationInput = {
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnsibleGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem_id?: IntFieldUpdateOperationsInput | number
  }

  export type ServerCreateInput = {
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    ansible_group?: AnsibleGroupCreateNestedOneWithoutServersInput
    environment?: EnvironmentCreateNestedOneWithoutServersInput
    softwares?: SoftwareVersionCreateNestedManyWithoutServersInput
  }

  export type ServerUncheckedCreateInput = {
    id?: number
    hostname: string
    ansible_group_id?: number | null
    date_created: Date | string
    date_changed: Date | string
    environment_id?: number | null
    softwares?: SoftwareVersionUncheckedCreateNestedManyWithoutServersInput
  }

  export type ServerUpdateInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    ansible_group?: AnsibleGroupUpdateOneWithoutServersNestedInput
    environment?: EnvironmentUpdateOneWithoutServersNestedInput
    softwares?: SoftwareVersionUpdateManyWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
    softwares?: SoftwareVersionUncheckedUpdateManyWithoutServersNestedInput
  }

  export type ServerCreateManyInput = {
    id?: number
    hostname: string
    ansible_group_id?: number | null
    date_created: Date | string
    date_changed: Date | string
    environment_id?: number | null
  }

  export type ServerUpdateManyMutationInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EnvironmentCreateInput = {
    name: string
    servers?: ServerCreateNestedManyWithoutEnvironmentInput
    approvals?: ApprovalCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateInput = {
    id?: number
    name: string
    servers?: ServerUncheckedCreateNestedManyWithoutEnvironmentInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    servers?: ServerUpdateManyWithoutEnvironmentNestedInput
    approvals?: ApprovalUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    servers?: ServerUncheckedUpdateManyWithoutEnvironmentNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentCreateManyInput = {
    id?: number
    name: string
  }

  export type EnvironmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EnvironmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SoftwareCreateInput = {
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUncheckedCreateInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareCreateManyInput = {
    id?: number
    name: string
    github?: string | null
  }

  export type SoftwareUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SoftwareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SoftwareVersionCreateInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionCreateManyInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
  }

  export type SoftwareVersionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SoftwareVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ApprovalCreateInput = {
    approver?: string | null
    date: Date | string
    environment?: EnvironmentCreateNestedOneWithoutApprovalsInput
    software_version?: SoftwareVersionCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: number
    approver?: string | null
    date: Date | string
    environment_id: number
    software_version_id?: number | null
  }

  export type ApprovalUpdateInput = {
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: EnvironmentUpdateOneWithoutApprovalsNestedInput
    software_version?: SoftwareVersionUpdateOneWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: IntFieldUpdateOperationsInput | number
    software_version_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalCreateManyInput = {
    id?: number
    approver?: string | null
    date: Date | string
    environment_id: number
    software_version_id?: number | null
  }

  export type ApprovalUpdateManyMutationInput = {
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: IntFieldUpdateOperationsInput | number
    software_version_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AnsibleGroupListRelationFilter = {
    every?: AnsibleGroupWhereInput
    some?: AnsibleGroupWhereInput
    none?: AnsibleGroupWhereInput
  }

  export type AnsibleGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EcosystemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EcosystemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EcosystemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EcosystemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EcosystemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EcosystemNullableRelationFilter = {
    is?: EcosystemWhereInput | null
    isNot?: EcosystemWhereInput | null
  }

  export type ServerListRelationFilter = {
    every?: ServerWhereInput
    some?: ServerWhereInput
    none?: ServerWhereInput
  }

  export type SoftwareListRelationFilter = {
    every?: SoftwareWhereInput
    some?: SoftwareWhereInput
    none?: SoftwareWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ServerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoftwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnsibleGroupCountOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    ecosystem_id?: SortOrder
  }

  export type AnsibleGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    ecosystem_id?: SortOrder
  }

  export type AnsibleGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    ecosystem_id?: SortOrder
  }

  export type AnsibleGroupMinOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    ecosystem_id?: SortOrder
  }

  export type AnsibleGroupSumOrderByAggregateInput = {
    id?: SortOrder
    ecosystem_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AnsibleGroupNullableRelationFilter = {
    is?: AnsibleGroupWhereInput | null
    isNot?: AnsibleGroupWhereInput | null
  }

  export type EnvironmentNullableRelationFilter = {
    is?: EnvironmentWhereInput | null
    isNot?: EnvironmentWhereInput | null
  }

  export type SoftwareVersionListRelationFilter = {
    every?: SoftwareVersionWhereInput
    some?: SoftwareVersionWhereInput
    none?: SoftwareVersionWhereInput
  }

  export type SoftwareVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServerCountOrderByAggregateInput = {
    id?: SortOrder
    hostname?: SortOrder
    ansible_group_id?: SortOrder
    date_created?: SortOrder
    date_changed?: SortOrder
    environment_id?: SortOrder
  }

  export type ServerAvgOrderByAggregateInput = {
    id?: SortOrder
    ansible_group_id?: SortOrder
    environment_id?: SortOrder
  }

  export type ServerMaxOrderByAggregateInput = {
    id?: SortOrder
    hostname?: SortOrder
    ansible_group_id?: SortOrder
    date_created?: SortOrder
    date_changed?: SortOrder
    environment_id?: SortOrder
  }

  export type ServerMinOrderByAggregateInput = {
    id?: SortOrder
    hostname?: SortOrder
    ansible_group_id?: SortOrder
    date_created?: SortOrder
    date_changed?: SortOrder
    environment_id?: SortOrder
  }

  export type ServerSumOrderByAggregateInput = {
    id?: SortOrder
    ansible_group_id?: SortOrder
    environment_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvironmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnvironmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnvironmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnvironmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnvironmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SoftwareVersionNullableRelationFilter = {
    is?: SoftwareVersionWhereInput | null
    isNot?: SoftwareVersionWhereInput | null
  }

  export type SoftwareCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
  }

  export type SoftwareAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SoftwareMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
  }

  export type SoftwareMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
  }

  export type SoftwareSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SoftwareNullableRelationFilter = {
    is?: SoftwareWhereInput | null
    isNot?: SoftwareWhereInput | null
  }

  export type SoftwareVersionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
    creator?: SortOrder
    last_editor?: SortOrder
    date_created?: SortOrder
    last_change?: SortOrder
    latest_release?: SortOrder
    software_id?: SortOrder
    approved_version_test_Id?: SortOrder
    approved_version_main_Id?: SortOrder
    newest_version_Id?: SortOrder
    approved?: SortOrder
  }

  export type SoftwareVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    software_id?: SortOrder
    approved_version_test_Id?: SortOrder
    approved_version_main_Id?: SortOrder
    newest_version_Id?: SortOrder
  }

  export type SoftwareVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
    creator?: SortOrder
    last_editor?: SortOrder
    date_created?: SortOrder
    last_change?: SortOrder
    latest_release?: SortOrder
    software_id?: SortOrder
    approved_version_test_Id?: SortOrder
    approved_version_main_Id?: SortOrder
    newest_version_Id?: SortOrder
    approved?: SortOrder
  }

  export type SoftwareVersionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    github?: SortOrder
    creator?: SortOrder
    last_editor?: SortOrder
    date_created?: SortOrder
    last_change?: SortOrder
    latest_release?: SortOrder
    software_id?: SortOrder
    approved_version_test_Id?: SortOrder
    approved_version_main_Id?: SortOrder
    newest_version_Id?: SortOrder
    approved?: SortOrder
  }

  export type SoftwareVersionSumOrderByAggregateInput = {
    id?: SortOrder
    software_id?: SortOrder
    approved_version_test_Id?: SortOrder
    approved_version_main_Id?: SortOrder
    newest_version_Id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    approver?: SortOrder
    date?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrder
  }

  export type ApprovalAvgOrderByAggregateInput = {
    id?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    approver?: SortOrder
    date?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    approver?: SortOrder
    date?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrder
  }

  export type ApprovalSumOrderByAggregateInput = {
    id?: SortOrder
    environment_id?: SortOrder
    software_version_id?: SortOrder
  }

  export type AnsibleGroupCreateNestedManyWithoutEcosystemInput = {
    create?: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput> | AnsibleGroupCreateWithoutEcosystemInput[] | AnsibleGroupUncheckedCreateWithoutEcosystemInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutEcosystemInput | AnsibleGroupCreateOrConnectWithoutEcosystemInput[]
    createMany?: AnsibleGroupCreateManyEcosystemInputEnvelope
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
  }

  export type AnsibleGroupUncheckedCreateNestedManyWithoutEcosystemInput = {
    create?: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput> | AnsibleGroupCreateWithoutEcosystemInput[] | AnsibleGroupUncheckedCreateWithoutEcosystemInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutEcosystemInput | AnsibleGroupCreateOrConnectWithoutEcosystemInput[]
    createMany?: AnsibleGroupCreateManyEcosystemInputEnvelope
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AnsibleGroupUpdateManyWithoutEcosystemNestedInput = {
    create?: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput> | AnsibleGroupCreateWithoutEcosystemInput[] | AnsibleGroupUncheckedCreateWithoutEcosystemInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutEcosystemInput | AnsibleGroupCreateOrConnectWithoutEcosystemInput[]
    upsert?: AnsibleGroupUpsertWithWhereUniqueWithoutEcosystemInput | AnsibleGroupUpsertWithWhereUniqueWithoutEcosystemInput[]
    createMany?: AnsibleGroupCreateManyEcosystemInputEnvelope
    set?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    disconnect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    delete?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    update?: AnsibleGroupUpdateWithWhereUniqueWithoutEcosystemInput | AnsibleGroupUpdateWithWhereUniqueWithoutEcosystemInput[]
    updateMany?: AnsibleGroupUpdateManyWithWhereWithoutEcosystemInput | AnsibleGroupUpdateManyWithWhereWithoutEcosystemInput[]
    deleteMany?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnsibleGroupUncheckedUpdateManyWithoutEcosystemNestedInput = {
    create?: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput> | AnsibleGroupCreateWithoutEcosystemInput[] | AnsibleGroupUncheckedCreateWithoutEcosystemInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutEcosystemInput | AnsibleGroupCreateOrConnectWithoutEcosystemInput[]
    upsert?: AnsibleGroupUpsertWithWhereUniqueWithoutEcosystemInput | AnsibleGroupUpsertWithWhereUniqueWithoutEcosystemInput[]
    createMany?: AnsibleGroupCreateManyEcosystemInputEnvelope
    set?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    disconnect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    delete?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    update?: AnsibleGroupUpdateWithWhereUniqueWithoutEcosystemInput | AnsibleGroupUpdateWithWhereUniqueWithoutEcosystemInput[]
    updateMany?: AnsibleGroupUpdateManyWithWhereWithoutEcosystemInput | AnsibleGroupUpdateManyWithWhereWithoutEcosystemInput[]
    deleteMany?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
  }

  export type EcosystemCreateNestedOneWithoutGroupsInput = {
    create?: XOR<EcosystemCreateWithoutGroupsInput, EcosystemUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: EcosystemCreateOrConnectWithoutGroupsInput
    connect?: EcosystemWhereUniqueInput
  }

  export type ServerCreateNestedManyWithoutAnsible_groupInput = {
    create?: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput> | ServerCreateWithoutAnsible_groupInput[] | ServerUncheckedCreateWithoutAnsible_groupInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutAnsible_groupInput | ServerCreateOrConnectWithoutAnsible_groupInput[]
    createMany?: ServerCreateManyAnsible_groupInputEnvelope
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutAnsible_groupsInput = {
    create?: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput> | SoftwareCreateWithoutAnsible_groupsInput[] | SoftwareUncheckedCreateWithoutAnsible_groupsInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutAnsible_groupsInput | SoftwareCreateOrConnectWithoutAnsible_groupsInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type ServerUncheckedCreateNestedManyWithoutAnsible_groupInput = {
    create?: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput> | ServerCreateWithoutAnsible_groupInput[] | ServerUncheckedCreateWithoutAnsible_groupInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutAnsible_groupInput | ServerCreateOrConnectWithoutAnsible_groupInput[]
    createMany?: ServerCreateManyAnsible_groupInputEnvelope
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutAnsible_groupsInput = {
    create?: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput> | SoftwareCreateWithoutAnsible_groupsInput[] | SoftwareUncheckedCreateWithoutAnsible_groupsInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutAnsible_groupsInput | SoftwareCreateOrConnectWithoutAnsible_groupsInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EcosystemUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<EcosystemCreateWithoutGroupsInput, EcosystemUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: EcosystemCreateOrConnectWithoutGroupsInput
    upsert?: EcosystemUpsertWithoutGroupsInput
    disconnect?: EcosystemWhereInput | boolean
    delete?: EcosystemWhereInput | boolean
    connect?: EcosystemWhereUniqueInput
    update?: XOR<XOR<EcosystemUpdateToOneWithWhereWithoutGroupsInput, EcosystemUpdateWithoutGroupsInput>, EcosystemUncheckedUpdateWithoutGroupsInput>
  }

  export type ServerUpdateManyWithoutAnsible_groupNestedInput = {
    create?: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput> | ServerCreateWithoutAnsible_groupInput[] | ServerUncheckedCreateWithoutAnsible_groupInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutAnsible_groupInput | ServerCreateOrConnectWithoutAnsible_groupInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutAnsible_groupInput | ServerUpsertWithWhereUniqueWithoutAnsible_groupInput[]
    createMany?: ServerCreateManyAnsible_groupInputEnvelope
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutAnsible_groupInput | ServerUpdateWithWhereUniqueWithoutAnsible_groupInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutAnsible_groupInput | ServerUpdateManyWithWhereWithoutAnsible_groupInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutAnsible_groupsNestedInput = {
    create?: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput> | SoftwareCreateWithoutAnsible_groupsInput[] | SoftwareUncheckedCreateWithoutAnsible_groupsInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutAnsible_groupsInput | SoftwareCreateOrConnectWithoutAnsible_groupsInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutAnsible_groupsInput | SoftwareUpsertWithWhereUniqueWithoutAnsible_groupsInput[]
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutAnsible_groupsInput | SoftwareUpdateWithWhereUniqueWithoutAnsible_groupsInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutAnsible_groupsInput | SoftwareUpdateManyWithWhereWithoutAnsible_groupsInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type ServerUncheckedUpdateManyWithoutAnsible_groupNestedInput = {
    create?: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput> | ServerCreateWithoutAnsible_groupInput[] | ServerUncheckedCreateWithoutAnsible_groupInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutAnsible_groupInput | ServerCreateOrConnectWithoutAnsible_groupInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutAnsible_groupInput | ServerUpsertWithWhereUniqueWithoutAnsible_groupInput[]
    createMany?: ServerCreateManyAnsible_groupInputEnvelope
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutAnsible_groupInput | ServerUpdateWithWhereUniqueWithoutAnsible_groupInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutAnsible_groupInput | ServerUpdateManyWithWhereWithoutAnsible_groupInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutAnsible_groupsNestedInput = {
    create?: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput> | SoftwareCreateWithoutAnsible_groupsInput[] | SoftwareUncheckedCreateWithoutAnsible_groupsInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutAnsible_groupsInput | SoftwareCreateOrConnectWithoutAnsible_groupsInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutAnsible_groupsInput | SoftwareUpsertWithWhereUniqueWithoutAnsible_groupsInput[]
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutAnsible_groupsInput | SoftwareUpdateWithWhereUniqueWithoutAnsible_groupsInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutAnsible_groupsInput | SoftwareUpdateManyWithWhereWithoutAnsible_groupsInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type AnsibleGroupCreateNestedOneWithoutServersInput = {
    create?: XOR<AnsibleGroupCreateWithoutServersInput, AnsibleGroupUncheckedCreateWithoutServersInput>
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutServersInput
    connect?: AnsibleGroupWhereUniqueInput
  }

  export type EnvironmentCreateNestedOneWithoutServersInput = {
    create?: XOR<EnvironmentCreateWithoutServersInput, EnvironmentUncheckedCreateWithoutServersInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutServersInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type SoftwareVersionCreateNestedManyWithoutServersInput = {
    create?: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput> | SoftwareVersionCreateWithoutServersInput[] | SoftwareVersionUncheckedCreateWithoutServersInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutServersInput | SoftwareVersionCreateOrConnectWithoutServersInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
  }

  export type SoftwareVersionUncheckedCreateNestedManyWithoutServersInput = {
    create?: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput> | SoftwareVersionCreateWithoutServersInput[] | SoftwareVersionUncheckedCreateWithoutServersInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutServersInput | SoftwareVersionCreateOrConnectWithoutServersInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AnsibleGroupUpdateOneWithoutServersNestedInput = {
    create?: XOR<AnsibleGroupCreateWithoutServersInput, AnsibleGroupUncheckedCreateWithoutServersInput>
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutServersInput
    upsert?: AnsibleGroupUpsertWithoutServersInput
    disconnect?: AnsibleGroupWhereInput | boolean
    delete?: AnsibleGroupWhereInput | boolean
    connect?: AnsibleGroupWhereUniqueInput
    update?: XOR<XOR<AnsibleGroupUpdateToOneWithWhereWithoutServersInput, AnsibleGroupUpdateWithoutServersInput>, AnsibleGroupUncheckedUpdateWithoutServersInput>
  }

  export type EnvironmentUpdateOneWithoutServersNestedInput = {
    create?: XOR<EnvironmentCreateWithoutServersInput, EnvironmentUncheckedCreateWithoutServersInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutServersInput
    upsert?: EnvironmentUpsertWithoutServersInput
    disconnect?: EnvironmentWhereInput | boolean
    delete?: EnvironmentWhereInput | boolean
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutServersInput, EnvironmentUpdateWithoutServersInput>, EnvironmentUncheckedUpdateWithoutServersInput>
  }

  export type SoftwareVersionUpdateManyWithoutServersNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput> | SoftwareVersionCreateWithoutServersInput[] | SoftwareVersionUncheckedCreateWithoutServersInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutServersInput | SoftwareVersionCreateOrConnectWithoutServersInput[]
    upsert?: SoftwareVersionUpsertWithWhereUniqueWithoutServersInput | SoftwareVersionUpsertWithWhereUniqueWithoutServersInput[]
    set?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    disconnect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    delete?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    update?: SoftwareVersionUpdateWithWhereUniqueWithoutServersInput | SoftwareVersionUpdateWithWhereUniqueWithoutServersInput[]
    updateMany?: SoftwareVersionUpdateManyWithWhereWithoutServersInput | SoftwareVersionUpdateManyWithWhereWithoutServersInput[]
    deleteMany?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SoftwareVersionUncheckedUpdateManyWithoutServersNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput> | SoftwareVersionCreateWithoutServersInput[] | SoftwareVersionUncheckedCreateWithoutServersInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutServersInput | SoftwareVersionCreateOrConnectWithoutServersInput[]
    upsert?: SoftwareVersionUpsertWithWhereUniqueWithoutServersInput | SoftwareVersionUpsertWithWhereUniqueWithoutServersInput[]
    set?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    disconnect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    delete?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    update?: SoftwareVersionUpdateWithWhereUniqueWithoutServersInput | SoftwareVersionUpdateWithWhereUniqueWithoutServersInput[]
    updateMany?: SoftwareVersionUpdateManyWithWhereWithoutServersInput | SoftwareVersionUpdateManyWithWhereWithoutServersInput[]
    deleteMany?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
  }

  export type ServerCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput> | ServerCreateWithoutEnvironmentInput[] | ServerUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutEnvironmentInput | ServerCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ServerCreateManyEnvironmentInputEnvelope
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput> | ApprovalCreateWithoutEnvironmentInput[] | ApprovalUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutEnvironmentInput | ApprovalCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ApprovalCreateManyEnvironmentInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ServerUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput> | ServerCreateWithoutEnvironmentInput[] | ServerUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutEnvironmentInput | ServerCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ServerCreateManyEnvironmentInputEnvelope
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput> | ApprovalCreateWithoutEnvironmentInput[] | ApprovalUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutEnvironmentInput | ApprovalCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ApprovalCreateManyEnvironmentInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ServerUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput> | ServerCreateWithoutEnvironmentInput[] | ServerUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutEnvironmentInput | ServerCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutEnvironmentInput | ServerUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ServerCreateManyEnvironmentInputEnvelope
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutEnvironmentInput | ServerUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutEnvironmentInput | ServerUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput> | ApprovalCreateWithoutEnvironmentInput[] | ApprovalUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutEnvironmentInput | ApprovalCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutEnvironmentInput | ApprovalUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ApprovalCreateManyEnvironmentInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutEnvironmentInput | ApprovalUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutEnvironmentInput | ApprovalUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ServerUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput> | ServerCreateWithoutEnvironmentInput[] | ServerUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutEnvironmentInput | ServerCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutEnvironmentInput | ServerUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ServerCreateManyEnvironmentInputEnvelope
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutEnvironmentInput | ServerUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutEnvironmentInput | ServerUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput> | ApprovalCreateWithoutEnvironmentInput[] | ApprovalUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutEnvironmentInput | ApprovalCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutEnvironmentInput | ApprovalUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ApprovalCreateManyEnvironmentInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutEnvironmentInput | ApprovalUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutEnvironmentInput | ApprovalUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type SoftwareVersionCreateNestedOneWithoutApproved_version_testInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_testInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_mainInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionCreateNestedOneWithoutNewest_versionInput = {
    create?: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutNewest_versionInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionCreateNestedManyWithoutSoftwareInput = {
    create?: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput> | SoftwareVersionCreateWithoutSoftwareInput[] | SoftwareVersionUncheckedCreateWithoutSoftwareInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutSoftwareInput | SoftwareVersionCreateOrConnectWithoutSoftwareInput[]
    createMany?: SoftwareVersionCreateManySoftwareInputEnvelope
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
  }

  export type AnsibleGroupCreateNestedManyWithoutSoftwaresInput = {
    create?: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput> | AnsibleGroupCreateWithoutSoftwaresInput[] | AnsibleGroupUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutSoftwaresInput | AnsibleGroupCreateOrConnectWithoutSoftwaresInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
  }

  export type SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_testInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_mainInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput = {
    create?: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutNewest_versionInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput = {
    create?: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput> | SoftwareVersionCreateWithoutSoftwareInput[] | SoftwareVersionUncheckedCreateWithoutSoftwareInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutSoftwareInput | SoftwareVersionCreateOrConnectWithoutSoftwareInput[]
    createMany?: SoftwareVersionCreateManySoftwareInputEnvelope
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
  }

  export type AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput = {
    create?: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput> | AnsibleGroupCreateWithoutSoftwaresInput[] | AnsibleGroupUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutSoftwaresInput | AnsibleGroupCreateOrConnectWithoutSoftwaresInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
  }

  export type SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_testInput
    upsert?: SoftwareVersionUpsertWithoutApproved_version_testInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_testInput, SoftwareVersionUpdateWithoutApproved_version_testInput>, SoftwareVersionUncheckedUpdateWithoutApproved_version_testInput>
  }

  export type SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_mainInput
    upsert?: SoftwareVersionUpsertWithoutApproved_version_mainInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_mainInput, SoftwareVersionUpdateWithoutApproved_version_mainInput>, SoftwareVersionUncheckedUpdateWithoutApproved_version_mainInput>
  }

  export type SoftwareVersionUpdateOneWithoutNewest_versionNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutNewest_versionInput
    upsert?: SoftwareVersionUpsertWithoutNewest_versionInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutNewest_versionInput, SoftwareVersionUpdateWithoutNewest_versionInput>, SoftwareVersionUncheckedUpdateWithoutNewest_versionInput>
  }

  export type SoftwareVersionUpdateManyWithoutSoftwareNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput> | SoftwareVersionCreateWithoutSoftwareInput[] | SoftwareVersionUncheckedCreateWithoutSoftwareInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutSoftwareInput | SoftwareVersionCreateOrConnectWithoutSoftwareInput[]
    upsert?: SoftwareVersionUpsertWithWhereUniqueWithoutSoftwareInput | SoftwareVersionUpsertWithWhereUniqueWithoutSoftwareInput[]
    createMany?: SoftwareVersionCreateManySoftwareInputEnvelope
    set?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    disconnect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    delete?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    update?: SoftwareVersionUpdateWithWhereUniqueWithoutSoftwareInput | SoftwareVersionUpdateWithWhereUniqueWithoutSoftwareInput[]
    updateMany?: SoftwareVersionUpdateManyWithWhereWithoutSoftwareInput | SoftwareVersionUpdateManyWithWhereWithoutSoftwareInput[]
    deleteMany?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
  }

  export type AnsibleGroupUpdateManyWithoutSoftwaresNestedInput = {
    create?: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput> | AnsibleGroupCreateWithoutSoftwaresInput[] | AnsibleGroupUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutSoftwaresInput | AnsibleGroupCreateOrConnectWithoutSoftwaresInput[]
    upsert?: AnsibleGroupUpsertWithWhereUniqueWithoutSoftwaresInput | AnsibleGroupUpsertWithWhereUniqueWithoutSoftwaresInput[]
    set?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    disconnect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    delete?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    update?: AnsibleGroupUpdateWithWhereUniqueWithoutSoftwaresInput | AnsibleGroupUpdateWithWhereUniqueWithoutSoftwaresInput[]
    updateMany?: AnsibleGroupUpdateManyWithWhereWithoutSoftwaresInput | AnsibleGroupUpdateManyWithWhereWithoutSoftwaresInput[]
    deleteMany?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
  }

  export type SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_testInput
    upsert?: SoftwareVersionUpsertWithoutApproved_version_testInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_testInput, SoftwareVersionUpdateWithoutApproved_version_testInput>, SoftwareVersionUncheckedUpdateWithoutApproved_version_testInput>
  }

  export type SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApproved_version_mainInput
    upsert?: SoftwareVersionUpsertWithoutApproved_version_mainInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_mainInput, SoftwareVersionUpdateWithoutApproved_version_mainInput>, SoftwareVersionUncheckedUpdateWithoutApproved_version_mainInput>
  }

  export type SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutNewest_versionInput
    upsert?: SoftwareVersionUpsertWithoutNewest_versionInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutNewest_versionInput, SoftwareVersionUpdateWithoutNewest_versionInput>, SoftwareVersionUncheckedUpdateWithoutNewest_versionInput>
  }

  export type SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput> | SoftwareVersionCreateWithoutSoftwareInput[] | SoftwareVersionUncheckedCreateWithoutSoftwareInput[]
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutSoftwareInput | SoftwareVersionCreateOrConnectWithoutSoftwareInput[]
    upsert?: SoftwareVersionUpsertWithWhereUniqueWithoutSoftwareInput | SoftwareVersionUpsertWithWhereUniqueWithoutSoftwareInput[]
    createMany?: SoftwareVersionCreateManySoftwareInputEnvelope
    set?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    disconnect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    delete?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    connect?: SoftwareVersionWhereUniqueInput | SoftwareVersionWhereUniqueInput[]
    update?: SoftwareVersionUpdateWithWhereUniqueWithoutSoftwareInput | SoftwareVersionUpdateWithWhereUniqueWithoutSoftwareInput[]
    updateMany?: SoftwareVersionUpdateManyWithWhereWithoutSoftwareInput | SoftwareVersionUpdateManyWithWhereWithoutSoftwareInput[]
    deleteMany?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
  }

  export type AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput = {
    create?: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput> | AnsibleGroupCreateWithoutSoftwaresInput[] | AnsibleGroupUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: AnsibleGroupCreateOrConnectWithoutSoftwaresInput | AnsibleGroupCreateOrConnectWithoutSoftwaresInput[]
    upsert?: AnsibleGroupUpsertWithWhereUniqueWithoutSoftwaresInput | AnsibleGroupUpsertWithWhereUniqueWithoutSoftwaresInput[]
    set?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    disconnect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    delete?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    connect?: AnsibleGroupWhereUniqueInput | AnsibleGroupWhereUniqueInput[]
    update?: AnsibleGroupUpdateWithWhereUniqueWithoutSoftwaresInput | AnsibleGroupUpdateWithWhereUniqueWithoutSoftwaresInput[]
    updateMany?: AnsibleGroupUpdateManyWithWhereWithoutSoftwaresInput | AnsibleGroupUpdateManyWithWhereWithoutSoftwaresInput[]
    deleteMany?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
  }

  export type SoftwareCreateNestedOneWithoutVersionsInput = {
    create?: XOR<SoftwareCreateWithoutVersionsInput, SoftwareUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutVersionsInput
    connect?: SoftwareWhereUniqueInput
  }

  export type SoftwareCreateNestedOneWithoutApproved_version_testInput = {
    create?: XOR<SoftwareCreateWithoutApproved_version_testInput, SoftwareUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutApproved_version_testInput
    connect?: SoftwareWhereUniqueInput
  }

  export type SoftwareCreateNestedOneWithoutApproved_version_mainInput = {
    create?: XOR<SoftwareCreateWithoutApproved_version_mainInput, SoftwareUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutApproved_version_mainInput
    connect?: SoftwareWhereUniqueInput
  }

  export type SoftwareCreateNestedOneWithoutNewest_versionInput = {
    create?: XOR<SoftwareCreateWithoutNewest_versionInput, SoftwareUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutNewest_versionInput
    connect?: SoftwareWhereUniqueInput
  }

  export type ServerCreateNestedManyWithoutSoftwaresInput = {
    create?: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput> | ServerCreateWithoutSoftwaresInput[] | ServerUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutSoftwaresInput | ServerCreateOrConnectWithoutSoftwaresInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutSoftware_versionInput = {
    create?: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput> | ApprovalCreateWithoutSoftware_versionInput[] | ApprovalUncheckedCreateWithoutSoftware_versionInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutSoftware_versionInput | ApprovalCreateOrConnectWithoutSoftware_versionInput[]
    createMany?: ApprovalCreateManySoftware_versionInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ServerUncheckedCreateNestedManyWithoutSoftwaresInput = {
    create?: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput> | ServerCreateWithoutSoftwaresInput[] | ServerUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutSoftwaresInput | ServerCreateOrConnectWithoutSoftwaresInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput = {
    create?: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput> | ApprovalCreateWithoutSoftware_versionInput[] | ApprovalUncheckedCreateWithoutSoftware_versionInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutSoftware_versionInput | ApprovalCreateOrConnectWithoutSoftware_versionInput[]
    createMany?: ApprovalCreateManySoftware_versionInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SoftwareUpdateOneWithoutVersionsNestedInput = {
    create?: XOR<SoftwareCreateWithoutVersionsInput, SoftwareUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutVersionsInput
    upsert?: SoftwareUpsertWithoutVersionsInput
    disconnect?: SoftwareWhereInput | boolean
    delete?: SoftwareWhereInput | boolean
    connect?: SoftwareWhereUniqueInput
    update?: XOR<XOR<SoftwareUpdateToOneWithWhereWithoutVersionsInput, SoftwareUpdateWithoutVersionsInput>, SoftwareUncheckedUpdateWithoutVersionsInput>
  }

  export type SoftwareUpdateOneWithoutApproved_version_testNestedInput = {
    create?: XOR<SoftwareCreateWithoutApproved_version_testInput, SoftwareUncheckedCreateWithoutApproved_version_testInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutApproved_version_testInput
    upsert?: SoftwareUpsertWithoutApproved_version_testInput
    disconnect?: SoftwareWhereInput | boolean
    delete?: SoftwareWhereInput | boolean
    connect?: SoftwareWhereUniqueInput
    update?: XOR<XOR<SoftwareUpdateToOneWithWhereWithoutApproved_version_testInput, SoftwareUpdateWithoutApproved_version_testInput>, SoftwareUncheckedUpdateWithoutApproved_version_testInput>
  }

  export type SoftwareUpdateOneWithoutApproved_version_mainNestedInput = {
    create?: XOR<SoftwareCreateWithoutApproved_version_mainInput, SoftwareUncheckedCreateWithoutApproved_version_mainInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutApproved_version_mainInput
    upsert?: SoftwareUpsertWithoutApproved_version_mainInput
    disconnect?: SoftwareWhereInput | boolean
    delete?: SoftwareWhereInput | boolean
    connect?: SoftwareWhereUniqueInput
    update?: XOR<XOR<SoftwareUpdateToOneWithWhereWithoutApproved_version_mainInput, SoftwareUpdateWithoutApproved_version_mainInput>, SoftwareUncheckedUpdateWithoutApproved_version_mainInput>
  }

  export type SoftwareUpdateOneWithoutNewest_versionNestedInput = {
    create?: XOR<SoftwareCreateWithoutNewest_versionInput, SoftwareUncheckedCreateWithoutNewest_versionInput>
    connectOrCreate?: SoftwareCreateOrConnectWithoutNewest_versionInput
    upsert?: SoftwareUpsertWithoutNewest_versionInput
    disconnect?: SoftwareWhereInput | boolean
    delete?: SoftwareWhereInput | boolean
    connect?: SoftwareWhereUniqueInput
    update?: XOR<XOR<SoftwareUpdateToOneWithWhereWithoutNewest_versionInput, SoftwareUpdateWithoutNewest_versionInput>, SoftwareUncheckedUpdateWithoutNewest_versionInput>
  }

  export type ServerUpdateManyWithoutSoftwaresNestedInput = {
    create?: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput> | ServerCreateWithoutSoftwaresInput[] | ServerUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutSoftwaresInput | ServerCreateOrConnectWithoutSoftwaresInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutSoftwaresInput | ServerUpsertWithWhereUniqueWithoutSoftwaresInput[]
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutSoftwaresInput | ServerUpdateWithWhereUniqueWithoutSoftwaresInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutSoftwaresInput | ServerUpdateManyWithWhereWithoutSoftwaresInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutSoftware_versionNestedInput = {
    create?: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput> | ApprovalCreateWithoutSoftware_versionInput[] | ApprovalUncheckedCreateWithoutSoftware_versionInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutSoftware_versionInput | ApprovalCreateOrConnectWithoutSoftware_versionInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutSoftware_versionInput | ApprovalUpsertWithWhereUniqueWithoutSoftware_versionInput[]
    createMany?: ApprovalCreateManySoftware_versionInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutSoftware_versionInput | ApprovalUpdateWithWhereUniqueWithoutSoftware_versionInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutSoftware_versionInput | ApprovalUpdateManyWithWhereWithoutSoftware_versionInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ServerUncheckedUpdateManyWithoutSoftwaresNestedInput = {
    create?: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput> | ServerCreateWithoutSoftwaresInput[] | ServerUncheckedCreateWithoutSoftwaresInput[]
    connectOrCreate?: ServerCreateOrConnectWithoutSoftwaresInput | ServerCreateOrConnectWithoutSoftwaresInput[]
    upsert?: ServerUpsertWithWhereUniqueWithoutSoftwaresInput | ServerUpsertWithWhereUniqueWithoutSoftwaresInput[]
    set?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    disconnect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    delete?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    connect?: ServerWhereUniqueInput | ServerWhereUniqueInput[]
    update?: ServerUpdateWithWhereUniqueWithoutSoftwaresInput | ServerUpdateWithWhereUniqueWithoutSoftwaresInput[]
    updateMany?: ServerUpdateManyWithWhereWithoutSoftwaresInput | ServerUpdateManyWithWhereWithoutSoftwaresInput[]
    deleteMany?: ServerScalarWhereInput | ServerScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput = {
    create?: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput> | ApprovalCreateWithoutSoftware_versionInput[] | ApprovalUncheckedCreateWithoutSoftware_versionInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutSoftware_versionInput | ApprovalCreateOrConnectWithoutSoftware_versionInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutSoftware_versionInput | ApprovalUpsertWithWhereUniqueWithoutSoftware_versionInput[]
    createMany?: ApprovalCreateManySoftware_versionInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutSoftware_versionInput | ApprovalUpdateWithWhereUniqueWithoutSoftware_versionInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutSoftware_versionInput | ApprovalUpdateManyWithWhereWithoutSoftware_versionInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type EnvironmentCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<EnvironmentCreateWithoutApprovalsInput, EnvironmentUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutApprovalsInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type SoftwareVersionCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<SoftwareVersionCreateWithoutApprovalsInput, SoftwareVersionUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApprovalsInput
    connect?: SoftwareVersionWhereUniqueInput
  }

  export type EnvironmentUpdateOneWithoutApprovalsNestedInput = {
    create?: XOR<EnvironmentCreateWithoutApprovalsInput, EnvironmentUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutApprovalsInput
    upsert?: EnvironmentUpsertWithoutApprovalsInput
    disconnect?: EnvironmentWhereInput | boolean
    delete?: EnvironmentWhereInput | boolean
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutApprovalsInput, EnvironmentUpdateWithoutApprovalsInput>, EnvironmentUncheckedUpdateWithoutApprovalsInput>
  }

  export type SoftwareVersionUpdateOneWithoutApprovalsNestedInput = {
    create?: XOR<SoftwareVersionCreateWithoutApprovalsInput, SoftwareVersionUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: SoftwareVersionCreateOrConnectWithoutApprovalsInput
    upsert?: SoftwareVersionUpsertWithoutApprovalsInput
    disconnect?: SoftwareVersionWhereInput | boolean
    delete?: SoftwareVersionWhereInput | boolean
    connect?: SoftwareVersionWhereUniqueInput
    update?: XOR<XOR<SoftwareVersionUpdateToOneWithWhereWithoutApprovalsInput, SoftwareVersionUpdateWithoutApprovalsInput>, SoftwareVersionUncheckedUpdateWithoutApprovalsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AnsibleGroupCreateWithoutEcosystemInput = {
    group_name?: string | null
    servers?: ServerCreateNestedManyWithoutAnsible_groupInput
    softwares?: SoftwareCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupUncheckedCreateWithoutEcosystemInput = {
    id?: number
    group_name?: string | null
    servers?: ServerUncheckedCreateNestedManyWithoutAnsible_groupInput
    softwares?: SoftwareUncheckedCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupCreateOrConnectWithoutEcosystemInput = {
    where: AnsibleGroupWhereUniqueInput
    create: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput>
  }

  export type AnsibleGroupCreateManyEcosystemInputEnvelope = {
    data: AnsibleGroupCreateManyEcosystemInput | AnsibleGroupCreateManyEcosystemInput[]
    skipDuplicates?: boolean
  }

  export type AnsibleGroupUpsertWithWhereUniqueWithoutEcosystemInput = {
    where: AnsibleGroupWhereUniqueInput
    update: XOR<AnsibleGroupUpdateWithoutEcosystemInput, AnsibleGroupUncheckedUpdateWithoutEcosystemInput>
    create: XOR<AnsibleGroupCreateWithoutEcosystemInput, AnsibleGroupUncheckedCreateWithoutEcosystemInput>
  }

  export type AnsibleGroupUpdateWithWhereUniqueWithoutEcosystemInput = {
    where: AnsibleGroupWhereUniqueInput
    data: XOR<AnsibleGroupUpdateWithoutEcosystemInput, AnsibleGroupUncheckedUpdateWithoutEcosystemInput>
  }

  export type AnsibleGroupUpdateManyWithWhereWithoutEcosystemInput = {
    where: AnsibleGroupScalarWhereInput
    data: XOR<AnsibleGroupUpdateManyMutationInput, AnsibleGroupUncheckedUpdateManyWithoutEcosystemInput>
  }

  export type AnsibleGroupScalarWhereInput = {
    AND?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
    OR?: AnsibleGroupScalarWhereInput[]
    NOT?: AnsibleGroupScalarWhereInput | AnsibleGroupScalarWhereInput[]
    id?: IntFilter<"AnsibleGroup"> | number
    group_name?: StringNullableFilter<"AnsibleGroup"> | string | null
    ecosystem_id?: IntFilter<"AnsibleGroup"> | number
  }

  export type EcosystemCreateWithoutGroupsInput = {
    name: string
  }

  export type EcosystemUncheckedCreateWithoutGroupsInput = {
    id?: number
    name: string
  }

  export type EcosystemCreateOrConnectWithoutGroupsInput = {
    where: EcosystemWhereUniqueInput
    create: XOR<EcosystemCreateWithoutGroupsInput, EcosystemUncheckedCreateWithoutGroupsInput>
  }

  export type ServerCreateWithoutAnsible_groupInput = {
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    environment?: EnvironmentCreateNestedOneWithoutServersInput
    softwares?: SoftwareVersionCreateNestedManyWithoutServersInput
  }

  export type ServerUncheckedCreateWithoutAnsible_groupInput = {
    id?: number
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    environment_id?: number | null
    softwares?: SoftwareVersionUncheckedCreateNestedManyWithoutServersInput
  }

  export type ServerCreateOrConnectWithoutAnsible_groupInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput>
  }

  export type ServerCreateManyAnsible_groupInputEnvelope = {
    data: ServerCreateManyAnsible_groupInput | ServerCreateManyAnsible_groupInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutAnsible_groupsInput = {
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionCreateNestedManyWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutAnsible_groupsInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput
  }

  export type SoftwareCreateOrConnectWithoutAnsible_groupsInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput>
  }

  export type EcosystemUpsertWithoutGroupsInput = {
    update: XOR<EcosystemUpdateWithoutGroupsInput, EcosystemUncheckedUpdateWithoutGroupsInput>
    create: XOR<EcosystemCreateWithoutGroupsInput, EcosystemUncheckedCreateWithoutGroupsInput>
    where?: EcosystemWhereInput
  }

  export type EcosystemUpdateToOneWithWhereWithoutGroupsInput = {
    where?: EcosystemWhereInput
    data: XOR<EcosystemUpdateWithoutGroupsInput, EcosystemUncheckedUpdateWithoutGroupsInput>
  }

  export type EcosystemUpdateWithoutGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EcosystemUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServerUpsertWithWhereUniqueWithoutAnsible_groupInput = {
    where: ServerWhereUniqueInput
    update: XOR<ServerUpdateWithoutAnsible_groupInput, ServerUncheckedUpdateWithoutAnsible_groupInput>
    create: XOR<ServerCreateWithoutAnsible_groupInput, ServerUncheckedCreateWithoutAnsible_groupInput>
  }

  export type ServerUpdateWithWhereUniqueWithoutAnsible_groupInput = {
    where: ServerWhereUniqueInput
    data: XOR<ServerUpdateWithoutAnsible_groupInput, ServerUncheckedUpdateWithoutAnsible_groupInput>
  }

  export type ServerUpdateManyWithWhereWithoutAnsible_groupInput = {
    where: ServerScalarWhereInput
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyWithoutAnsible_groupInput>
  }

  export type ServerScalarWhereInput = {
    AND?: ServerScalarWhereInput | ServerScalarWhereInput[]
    OR?: ServerScalarWhereInput[]
    NOT?: ServerScalarWhereInput | ServerScalarWhereInput[]
    id?: IntFilter<"Server"> | number
    hostname?: StringFilter<"Server"> | string
    ansible_group_id?: IntNullableFilter<"Server"> | number | null
    date_created?: DateTimeFilter<"Server"> | Date | string
    date_changed?: DateTimeFilter<"Server"> | Date | string
    environment_id?: IntNullableFilter<"Server"> | number | null
  }

  export type SoftwareUpsertWithWhereUniqueWithoutAnsible_groupsInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutAnsible_groupsInput, SoftwareUncheckedUpdateWithoutAnsible_groupsInput>
    create: XOR<SoftwareCreateWithoutAnsible_groupsInput, SoftwareUncheckedCreateWithoutAnsible_groupsInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutAnsible_groupsInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutAnsible_groupsInput, SoftwareUncheckedUpdateWithoutAnsible_groupsInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutAnsible_groupsInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutAnsible_groupsInput>
  }

  export type SoftwareScalarWhereInput = {
    AND?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    OR?: SoftwareScalarWhereInput[]
    NOT?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    id?: IntFilter<"Software"> | number
    name?: StringFilter<"Software"> | string
    github?: StringNullableFilter<"Software"> | string | null
  }

  export type AnsibleGroupCreateWithoutServersInput = {
    group_name?: string | null
    ecosystem?: EcosystemCreateNestedOneWithoutGroupsInput
    softwares?: SoftwareCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupUncheckedCreateWithoutServersInput = {
    id?: number
    group_name?: string | null
    ecosystem_id: number
    softwares?: SoftwareUncheckedCreateNestedManyWithoutAnsible_groupsInput
  }

  export type AnsibleGroupCreateOrConnectWithoutServersInput = {
    where: AnsibleGroupWhereUniqueInput
    create: XOR<AnsibleGroupCreateWithoutServersInput, AnsibleGroupUncheckedCreateWithoutServersInput>
  }

  export type EnvironmentCreateWithoutServersInput = {
    name: string
    approvals?: ApprovalCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateWithoutServersInput = {
    id?: number
    name: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentCreateOrConnectWithoutServersInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutServersInput, EnvironmentUncheckedCreateWithoutServersInput>
  }

  export type SoftwareVersionCreateWithoutServersInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateWithoutServersInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionCreateOrConnectWithoutServersInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput>
  }

  export type AnsibleGroupUpsertWithoutServersInput = {
    update: XOR<AnsibleGroupUpdateWithoutServersInput, AnsibleGroupUncheckedUpdateWithoutServersInput>
    create: XOR<AnsibleGroupCreateWithoutServersInput, AnsibleGroupUncheckedCreateWithoutServersInput>
    where?: AnsibleGroupWhereInput
  }

  export type AnsibleGroupUpdateToOneWithWhereWithoutServersInput = {
    where?: AnsibleGroupWhereInput
    data: XOR<AnsibleGroupUpdateWithoutServersInput, AnsibleGroupUncheckedUpdateWithoutServersInput>
  }

  export type AnsibleGroupUpdateWithoutServersInput = {
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem?: EcosystemUpdateOneWithoutGroupsNestedInput
    softwares?: SoftwareUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type AnsibleGroupUncheckedUpdateWithoutServersInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem_id?: IntFieldUpdateOperationsInput | number
    softwares?: SoftwareUncheckedUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type EnvironmentUpsertWithoutServersInput = {
    update: XOR<EnvironmentUpdateWithoutServersInput, EnvironmentUncheckedUpdateWithoutServersInput>
    create: XOR<EnvironmentCreateWithoutServersInput, EnvironmentUncheckedCreateWithoutServersInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutServersInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutServersInput, EnvironmentUncheckedUpdateWithoutServersInput>
  }

  export type EnvironmentUpdateWithoutServersInput = {
    name?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutServersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type SoftwareVersionUpsertWithWhereUniqueWithoutServersInput = {
    where: SoftwareVersionWhereUniqueInput
    update: XOR<SoftwareVersionUpdateWithoutServersInput, SoftwareVersionUncheckedUpdateWithoutServersInput>
    create: XOR<SoftwareVersionCreateWithoutServersInput, SoftwareVersionUncheckedCreateWithoutServersInput>
  }

  export type SoftwareVersionUpdateWithWhereUniqueWithoutServersInput = {
    where: SoftwareVersionWhereUniqueInput
    data: XOR<SoftwareVersionUpdateWithoutServersInput, SoftwareVersionUncheckedUpdateWithoutServersInput>
  }

  export type SoftwareVersionUpdateManyWithWhereWithoutServersInput = {
    where: SoftwareVersionScalarWhereInput
    data: XOR<SoftwareVersionUpdateManyMutationInput, SoftwareVersionUncheckedUpdateManyWithoutServersInput>
  }

  export type SoftwareVersionScalarWhereInput = {
    AND?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
    OR?: SoftwareVersionScalarWhereInput[]
    NOT?: SoftwareVersionScalarWhereInput | SoftwareVersionScalarWhereInput[]
    id?: IntFilter<"SoftwareVersion"> | number
    name?: StringFilter<"SoftwareVersion"> | string
    github?: StringNullableFilter<"SoftwareVersion"> | string | null
    creator?: StringNullableFilter<"SoftwareVersion"> | string | null
    last_editor?: StringNullableFilter<"SoftwareVersion"> | string | null
    date_created?: DateTimeFilter<"SoftwareVersion"> | Date | string
    last_change?: DateTimeFilter<"SoftwareVersion"> | Date | string
    latest_release?: StringNullableFilter<"SoftwareVersion"> | string | null
    software_id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved_version_test_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved_version_main_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    newest_version_Id?: IntNullableFilter<"SoftwareVersion"> | number | null
    approved?: BoolNullableFilter<"SoftwareVersion"> | boolean | null
  }

  export type ServerCreateWithoutEnvironmentInput = {
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    ansible_group?: AnsibleGroupCreateNestedOneWithoutServersInput
    softwares?: SoftwareVersionCreateNestedManyWithoutServersInput
  }

  export type ServerUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    hostname: string
    ansible_group_id?: number | null
    date_created: Date | string
    date_changed: Date | string
    softwares?: SoftwareVersionUncheckedCreateNestedManyWithoutServersInput
  }

  export type ServerCreateOrConnectWithoutEnvironmentInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput>
  }

  export type ServerCreateManyEnvironmentInputEnvelope = {
    data: ServerCreateManyEnvironmentInput | ServerCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutEnvironmentInput = {
    approver?: string | null
    date: Date | string
    software_version?: SoftwareVersionCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    approver?: string | null
    date: Date | string
    software_version_id?: number | null
  }

  export type ApprovalCreateOrConnectWithoutEnvironmentInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput>
  }

  export type ApprovalCreateManyEnvironmentInputEnvelope = {
    data: ApprovalCreateManyEnvironmentInput | ApprovalCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type ServerUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: ServerWhereUniqueInput
    update: XOR<ServerUpdateWithoutEnvironmentInput, ServerUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<ServerCreateWithoutEnvironmentInput, ServerUncheckedCreateWithoutEnvironmentInput>
  }

  export type ServerUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: ServerWhereUniqueInput
    data: XOR<ServerUpdateWithoutEnvironmentInput, ServerUncheckedUpdateWithoutEnvironmentInput>
  }

  export type ServerUpdateManyWithWhereWithoutEnvironmentInput = {
    where: ServerScalarWhereInput
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutEnvironmentInput, ApprovalUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<ApprovalCreateWithoutEnvironmentInput, ApprovalUncheckedCreateWithoutEnvironmentInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutEnvironmentInput, ApprovalUncheckedUpdateWithoutEnvironmentInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutEnvironmentInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: IntFilter<"Approval"> | number
    approver?: StringNullableFilter<"Approval"> | string | null
    date?: DateTimeFilter<"Approval"> | Date | string
    environment_id?: IntFilter<"Approval"> | number
    software_version_id?: IntNullableFilter<"Approval"> | number | null
  }

  export type SoftwareVersionCreateWithoutApproved_version_testInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateWithoutApproved_version_testInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionCreateOrConnectWithoutApproved_version_testInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
  }

  export type SoftwareVersionCreateWithoutApproved_version_mainInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionCreateOrConnectWithoutApproved_version_mainInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
  }

  export type SoftwareVersionCreateWithoutNewest_versionInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateWithoutNewest_versionInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionCreateOrConnectWithoutNewest_versionInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
  }

  export type SoftwareVersionCreateWithoutSoftwareInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionUncheckedCreateWithoutSoftwareInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutSoftware_versionInput
  }

  export type SoftwareVersionCreateOrConnectWithoutSoftwareInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput>
  }

  export type SoftwareVersionCreateManySoftwareInputEnvelope = {
    data: SoftwareVersionCreateManySoftwareInput | SoftwareVersionCreateManySoftwareInput[]
    skipDuplicates?: boolean
  }

  export type AnsibleGroupCreateWithoutSoftwaresInput = {
    group_name?: string | null
    ecosystem?: EcosystemCreateNestedOneWithoutGroupsInput
    servers?: ServerCreateNestedManyWithoutAnsible_groupInput
  }

  export type AnsibleGroupUncheckedCreateWithoutSoftwaresInput = {
    id?: number
    group_name?: string | null
    ecosystem_id: number
    servers?: ServerUncheckedCreateNestedManyWithoutAnsible_groupInput
  }

  export type AnsibleGroupCreateOrConnectWithoutSoftwaresInput = {
    where: AnsibleGroupWhereUniqueInput
    create: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput>
  }

  export type SoftwareVersionUpsertWithoutApproved_version_testInput = {
    update: XOR<SoftwareVersionUpdateWithoutApproved_version_testInput, SoftwareVersionUncheckedUpdateWithoutApproved_version_testInput>
    create: XOR<SoftwareVersionCreateWithoutApproved_version_testInput, SoftwareVersionUncheckedCreateWithoutApproved_version_testInput>
    where?: SoftwareVersionWhereInput
  }

  export type SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_testInput = {
    where?: SoftwareVersionWhereInput
    data: XOR<SoftwareVersionUpdateWithoutApproved_version_testInput, SoftwareVersionUncheckedUpdateWithoutApproved_version_testInput>
  }

  export type SoftwareVersionUpdateWithoutApproved_version_testInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutApproved_version_testInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUpsertWithoutApproved_version_mainInput = {
    update: XOR<SoftwareVersionUpdateWithoutApproved_version_mainInput, SoftwareVersionUncheckedUpdateWithoutApproved_version_mainInput>
    create: XOR<SoftwareVersionCreateWithoutApproved_version_mainInput, SoftwareVersionUncheckedCreateWithoutApproved_version_mainInput>
    where?: SoftwareVersionWhereInput
  }

  export type SoftwareVersionUpdateToOneWithWhereWithoutApproved_version_mainInput = {
    where?: SoftwareVersionWhereInput
    data: XOR<SoftwareVersionUpdateWithoutApproved_version_mainInput, SoftwareVersionUncheckedUpdateWithoutApproved_version_mainInput>
  }

  export type SoftwareVersionUpdateWithoutApproved_version_mainInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutApproved_version_mainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUpsertWithoutNewest_versionInput = {
    update: XOR<SoftwareVersionUpdateWithoutNewest_versionInput, SoftwareVersionUncheckedUpdateWithoutNewest_versionInput>
    create: XOR<SoftwareVersionCreateWithoutNewest_versionInput, SoftwareVersionUncheckedCreateWithoutNewest_versionInput>
    where?: SoftwareVersionWhereInput
  }

  export type SoftwareVersionUpdateToOneWithWhereWithoutNewest_versionInput = {
    where?: SoftwareVersionWhereInput
    data: XOR<SoftwareVersionUpdateWithoutNewest_versionInput, SoftwareVersionUncheckedUpdateWithoutNewest_versionInput>
  }

  export type SoftwareVersionUpdateWithoutNewest_versionInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutNewest_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUpsertWithWhereUniqueWithoutSoftwareInput = {
    where: SoftwareVersionWhereUniqueInput
    update: XOR<SoftwareVersionUpdateWithoutSoftwareInput, SoftwareVersionUncheckedUpdateWithoutSoftwareInput>
    create: XOR<SoftwareVersionCreateWithoutSoftwareInput, SoftwareVersionUncheckedCreateWithoutSoftwareInput>
  }

  export type SoftwareVersionUpdateWithWhereUniqueWithoutSoftwareInput = {
    where: SoftwareVersionWhereUniqueInput
    data: XOR<SoftwareVersionUpdateWithoutSoftwareInput, SoftwareVersionUncheckedUpdateWithoutSoftwareInput>
  }

  export type SoftwareVersionUpdateManyWithWhereWithoutSoftwareInput = {
    where: SoftwareVersionScalarWhereInput
    data: XOR<SoftwareVersionUpdateManyMutationInput, SoftwareVersionUncheckedUpdateManyWithoutSoftwareInput>
  }

  export type AnsibleGroupUpsertWithWhereUniqueWithoutSoftwaresInput = {
    where: AnsibleGroupWhereUniqueInput
    update: XOR<AnsibleGroupUpdateWithoutSoftwaresInput, AnsibleGroupUncheckedUpdateWithoutSoftwaresInput>
    create: XOR<AnsibleGroupCreateWithoutSoftwaresInput, AnsibleGroupUncheckedCreateWithoutSoftwaresInput>
  }

  export type AnsibleGroupUpdateWithWhereUniqueWithoutSoftwaresInput = {
    where: AnsibleGroupWhereUniqueInput
    data: XOR<AnsibleGroupUpdateWithoutSoftwaresInput, AnsibleGroupUncheckedUpdateWithoutSoftwaresInput>
  }

  export type AnsibleGroupUpdateManyWithWhereWithoutSoftwaresInput = {
    where: AnsibleGroupScalarWhereInput
    data: XOR<AnsibleGroupUpdateManyMutationInput, AnsibleGroupUncheckedUpdateManyWithoutSoftwaresInput>
  }

  export type SoftwareCreateWithoutVersionsInput = {
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionCreateNestedOneWithoutNewest_versionInput
    ansible_groups?: AnsibleGroupCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUncheckedCreateWithoutVersionsInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput
    ansible_groups?: AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareCreateOrConnectWithoutVersionsInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutVersionsInput, SoftwareUncheckedCreateWithoutVersionsInput>
  }

  export type SoftwareCreateWithoutApproved_version_testInput = {
    name: string
    github?: string | null
    approved_version_main?: SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUncheckedCreateWithoutApproved_version_testInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_main?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareCreateOrConnectWithoutApproved_version_testInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutApproved_version_testInput, SoftwareUncheckedCreateWithoutApproved_version_testInput>
  }

  export type SoftwareCreateWithoutApproved_version_mainInput = {
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionCreateNestedOneWithoutApproved_version_testInput
    newest_version?: SoftwareVersionCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUncheckedCreateWithoutApproved_version_mainInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput
    newest_version?: SoftwareVersionUncheckedCreateNestedOneWithoutNewest_versionInput
    versions?: SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareCreateOrConnectWithoutApproved_version_mainInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutApproved_version_mainInput, SoftwareUncheckedCreateWithoutApproved_version_mainInput>
  }

  export type SoftwareCreateWithoutNewest_versionInput = {
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionCreateNestedOneWithoutApproved_version_mainInput
    versions?: SoftwareVersionCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareUncheckedCreateWithoutNewest_versionInput = {
    id?: number
    name: string
    github?: string | null
    approved_version_test?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareVersionUncheckedCreateNestedOneWithoutApproved_version_mainInput
    versions?: SoftwareVersionUncheckedCreateNestedManyWithoutSoftwareInput
    ansible_groups?: AnsibleGroupUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareCreateOrConnectWithoutNewest_versionInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutNewest_versionInput, SoftwareUncheckedCreateWithoutNewest_versionInput>
  }

  export type ServerCreateWithoutSoftwaresInput = {
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    ansible_group?: AnsibleGroupCreateNestedOneWithoutServersInput
    environment?: EnvironmentCreateNestedOneWithoutServersInput
  }

  export type ServerUncheckedCreateWithoutSoftwaresInput = {
    id?: number
    hostname: string
    ansible_group_id?: number | null
    date_created: Date | string
    date_changed: Date | string
    environment_id?: number | null
  }

  export type ServerCreateOrConnectWithoutSoftwaresInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput>
  }

  export type ApprovalCreateWithoutSoftware_versionInput = {
    approver?: string | null
    date: Date | string
    environment?: EnvironmentCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutSoftware_versionInput = {
    id?: number
    approver?: string | null
    date: Date | string
    environment_id: number
  }

  export type ApprovalCreateOrConnectWithoutSoftware_versionInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput>
  }

  export type ApprovalCreateManySoftware_versionInputEnvelope = {
    data: ApprovalCreateManySoftware_versionInput | ApprovalCreateManySoftware_versionInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareUpsertWithoutVersionsInput = {
    update: XOR<SoftwareUpdateWithoutVersionsInput, SoftwareUncheckedUpdateWithoutVersionsInput>
    create: XOR<SoftwareCreateWithoutVersionsInput, SoftwareUncheckedCreateWithoutVersionsInput>
    where?: SoftwareWhereInput
  }

  export type SoftwareUpdateToOneWithWhereWithoutVersionsInput = {
    where?: SoftwareWhereInput
    data: XOR<SoftwareUpdateWithoutVersionsInput, SoftwareUncheckedUpdateWithoutVersionsInput>
  }

  export type SoftwareUpdateWithoutVersionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUpdateOneWithoutNewest_versionNestedInput
    ansible_groups?: AnsibleGroupUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput
    ansible_groups?: AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUpsertWithoutApproved_version_testInput = {
    update: XOR<SoftwareUpdateWithoutApproved_version_testInput, SoftwareUncheckedUpdateWithoutApproved_version_testInput>
    create: XOR<SoftwareCreateWithoutApproved_version_testInput, SoftwareUncheckedCreateWithoutApproved_version_testInput>
    where?: SoftwareWhereInput
  }

  export type SoftwareUpdateToOneWithWhereWithoutApproved_version_testInput = {
    where?: SoftwareWhereInput
    data: XOR<SoftwareUpdateWithoutApproved_version_testInput, SoftwareUncheckedUpdateWithoutApproved_version_testInput>
  }

  export type SoftwareUpdateWithoutApproved_version_testInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_main?: SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutApproved_version_testInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_main?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUpsertWithoutApproved_version_mainInput = {
    update: XOR<SoftwareUpdateWithoutApproved_version_mainInput, SoftwareUncheckedUpdateWithoutApproved_version_mainInput>
    create: XOR<SoftwareCreateWithoutApproved_version_mainInput, SoftwareUncheckedCreateWithoutApproved_version_mainInput>
    where?: SoftwareWhereInput
  }

  export type SoftwareUpdateToOneWithWhereWithoutApproved_version_mainInput = {
    where?: SoftwareWhereInput
    data: XOR<SoftwareUpdateWithoutApproved_version_mainInput, SoftwareUncheckedUpdateWithoutApproved_version_mainInput>
  }

  export type SoftwareUpdateWithoutApproved_version_mainInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput
    newest_version?: SoftwareVersionUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutApproved_version_mainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput
    newest_version?: SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUpsertWithoutNewest_versionInput = {
    update: XOR<SoftwareUpdateWithoutNewest_versionInput, SoftwareUncheckedUpdateWithoutNewest_versionInput>
    create: XOR<SoftwareCreateWithoutNewest_versionInput, SoftwareUncheckedCreateWithoutNewest_versionInput>
    where?: SoftwareWhereInput
  }

  export type SoftwareUpdateToOneWithWhereWithoutNewest_versionInput = {
    where?: SoftwareWhereInput
    data: XOR<SoftwareUpdateWithoutNewest_versionInput, SoftwareUncheckedUpdateWithoutNewest_versionInput>
  }

  export type SoftwareUpdateWithoutNewest_versionInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput
    versions?: SoftwareVersionUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutNewest_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput
    versions?: SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput
    ansible_groups?: AnsibleGroupUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type ServerUpsertWithWhereUniqueWithoutSoftwaresInput = {
    where: ServerWhereUniqueInput
    update: XOR<ServerUpdateWithoutSoftwaresInput, ServerUncheckedUpdateWithoutSoftwaresInput>
    create: XOR<ServerCreateWithoutSoftwaresInput, ServerUncheckedCreateWithoutSoftwaresInput>
  }

  export type ServerUpdateWithWhereUniqueWithoutSoftwaresInput = {
    where: ServerWhereUniqueInput
    data: XOR<ServerUpdateWithoutSoftwaresInput, ServerUncheckedUpdateWithoutSoftwaresInput>
  }

  export type ServerUpdateManyWithWhereWithoutSoftwaresInput = {
    where: ServerScalarWhereInput
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyWithoutSoftwaresInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutSoftware_versionInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutSoftware_versionInput, ApprovalUncheckedUpdateWithoutSoftware_versionInput>
    create: XOR<ApprovalCreateWithoutSoftware_versionInput, ApprovalUncheckedCreateWithoutSoftware_versionInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutSoftware_versionInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutSoftware_versionInput, ApprovalUncheckedUpdateWithoutSoftware_versionInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutSoftware_versionInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutSoftware_versionInput>
  }

  export type EnvironmentCreateWithoutApprovalsInput = {
    name: string
    servers?: ServerCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateWithoutApprovalsInput = {
    id?: number
    name: string
    servers?: ServerUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentCreateOrConnectWithoutApprovalsInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutApprovalsInput, EnvironmentUncheckedCreateWithoutApprovalsInput>
  }

  export type SoftwareVersionCreateWithoutApprovalsInput = {
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved?: boolean | null
    software?: SoftwareCreateNestedOneWithoutVersionsInput
    approved_version_test?: SoftwareCreateNestedOneWithoutApproved_version_testInput
    approved_version_main?: SoftwareCreateNestedOneWithoutApproved_version_mainInput
    newest_version?: SoftwareCreateNestedOneWithoutNewest_versionInput
    servers?: ServerCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareVersionUncheckedCreateWithoutApprovalsInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    software_id?: number | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
    servers?: ServerUncheckedCreateNestedManyWithoutSoftwaresInput
  }

  export type SoftwareVersionCreateOrConnectWithoutApprovalsInput = {
    where: SoftwareVersionWhereUniqueInput
    create: XOR<SoftwareVersionCreateWithoutApprovalsInput, SoftwareVersionUncheckedCreateWithoutApprovalsInput>
  }

  export type EnvironmentUpsertWithoutApprovalsInput = {
    update: XOR<EnvironmentUpdateWithoutApprovalsInput, EnvironmentUncheckedUpdateWithoutApprovalsInput>
    create: XOR<EnvironmentCreateWithoutApprovalsInput, EnvironmentUncheckedCreateWithoutApprovalsInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutApprovalsInput, EnvironmentUncheckedUpdateWithoutApprovalsInput>
  }

  export type EnvironmentUpdateWithoutApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    servers?: ServerUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    servers?: ServerUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type SoftwareVersionUpsertWithoutApprovalsInput = {
    update: XOR<SoftwareVersionUpdateWithoutApprovalsInput, SoftwareVersionUncheckedUpdateWithoutApprovalsInput>
    create: XOR<SoftwareVersionCreateWithoutApprovalsInput, SoftwareVersionUncheckedCreateWithoutApprovalsInput>
    where?: SoftwareVersionWhereInput
  }

  export type SoftwareVersionUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: SoftwareVersionWhereInput
    data: XOR<SoftwareVersionUpdateWithoutApprovalsInput, SoftwareVersionUncheckedUpdateWithoutApprovalsInput>
  }

  export type SoftwareVersionUpdateWithoutApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
  }

  export type AnsibleGroupCreateManyEcosystemInput = {
    id?: number
    group_name?: string | null
  }

  export type AnsibleGroupUpdateWithoutEcosystemInput = {
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    servers?: ServerUpdateManyWithoutAnsible_groupNestedInput
    softwares?: SoftwareUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type AnsibleGroupUncheckedUpdateWithoutEcosystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    servers?: ServerUncheckedUpdateManyWithoutAnsible_groupNestedInput
    softwares?: SoftwareUncheckedUpdateManyWithoutAnsible_groupsNestedInput
  }

  export type AnsibleGroupUncheckedUpdateManyWithoutEcosystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServerCreateManyAnsible_groupInput = {
    id?: number
    hostname: string
    date_created: Date | string
    date_changed: Date | string
    environment_id?: number | null
  }

  export type ServerUpdateWithoutAnsible_groupInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: EnvironmentUpdateOneWithoutServersNestedInput
    softwares?: SoftwareVersionUpdateManyWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateWithoutAnsible_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
    softwares?: SoftwareVersionUncheckedUpdateManyWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateManyWithoutAnsible_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SoftwareUpdateWithoutAnsible_groupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUpdateManyWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutAnsible_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareVersionUncheckedUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareVersionUncheckedUpdateOneWithoutNewest_versionNestedInput
    versions?: SoftwareVersionUncheckedUpdateManyWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateManyWithoutAnsible_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SoftwareVersionUpdateWithoutServersInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    software?: SoftwareUpdateOneWithoutVersionsNestedInput
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutServersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateManyWithoutServersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    software_id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ServerCreateManyEnvironmentInput = {
    id?: number
    hostname: string
    ansible_group_id?: number | null
    date_created: Date | string
    date_changed: Date | string
  }

  export type ApprovalCreateManyEnvironmentInput = {
    id?: number
    approver?: string | null
    date: Date | string
    software_version_id?: number | null
  }

  export type ServerUpdateWithoutEnvironmentInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    ansible_group?: AnsibleGroupUpdateOneWithoutServersNestedInput
    softwares?: SoftwareVersionUpdateManyWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    softwares?: SoftwareVersionUncheckedUpdateManyWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutEnvironmentInput = {
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    software_version?: SoftwareVersionUpdateOneWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    software_version_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    software_version_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SoftwareVersionCreateManySoftwareInput = {
    id?: number
    name: string
    github?: string | null
    creator?: string | null
    last_editor?: string | null
    date_created: Date | string
    last_change: Date | string
    latest_release?: string | null
    approved_version_test_Id?: number | null
    approved_version_main_Id?: number | null
    newest_version_Id?: number | null
    approved?: boolean | null
  }

  export type SoftwareVersionUpdateWithoutSoftwareInput = {
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approved_version_test?: SoftwareUpdateOneWithoutApproved_version_testNestedInput
    approved_version_main?: SoftwareUpdateOneWithoutApproved_version_mainNestedInput
    newest_version?: SoftwareUpdateOneWithoutNewest_versionNestedInput
    servers?: ServerUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateWithoutSoftwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    servers?: ServerUncheckedUpdateManyWithoutSoftwaresNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutSoftware_versionNestedInput
  }

  export type SoftwareVersionUncheckedUpdateManyWithoutSoftwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    github?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    last_editor?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_change?: DateTimeFieldUpdateOperationsInput | Date | string
    latest_release?: NullableStringFieldUpdateOperationsInput | string | null
    approved_version_test_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved_version_main_Id?: NullableIntFieldUpdateOperationsInput | number | null
    newest_version_Id?: NullableIntFieldUpdateOperationsInput | number | null
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnsibleGroupUpdateWithoutSoftwaresInput = {
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem?: EcosystemUpdateOneWithoutGroupsNestedInput
    servers?: ServerUpdateManyWithoutAnsible_groupNestedInput
  }

  export type AnsibleGroupUncheckedUpdateWithoutSoftwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem_id?: IntFieldUpdateOperationsInput | number
    servers?: ServerUncheckedUpdateManyWithoutAnsible_groupNestedInput
  }

  export type AnsibleGroupUncheckedUpdateManyWithoutSoftwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    ecosystem_id?: IntFieldUpdateOperationsInput | number
  }

  export type ApprovalCreateManySoftware_versionInput = {
    id?: number
    approver?: string | null
    date: Date | string
    environment_id: number
  }

  export type ServerUpdateWithoutSoftwaresInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    ansible_group?: AnsibleGroupUpdateOneWithoutServersNestedInput
    environment?: EnvironmentUpdateOneWithoutServersNestedInput
  }

  export type ServerUncheckedUpdateWithoutSoftwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServerUncheckedUpdateManyWithoutSoftwaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    ansible_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    date_changed?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalUpdateWithoutSoftware_versionInput = {
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: EnvironmentUpdateOneWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutSoftware_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: IntFieldUpdateOperationsInput | number
  }

  export type ApprovalUncheckedUpdateManyWithoutSoftware_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    environment_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EcosystemCountOutputTypeDefaultArgs instead
     */
    export type EcosystemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EcosystemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnsibleGroupCountOutputTypeDefaultArgs instead
     */
    export type AnsibleGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnsibleGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerCountOutputTypeDefaultArgs instead
     */
    export type ServerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvironmentCountOutputTypeDefaultArgs instead
     */
    export type EnvironmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareCountOutputTypeDefaultArgs instead
     */
    export type SoftwareCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareVersionCountOutputTypeDefaultArgs instead
     */
    export type SoftwareVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EcosystemDefaultArgs instead
     */
    export type EcosystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EcosystemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnsibleGroupDefaultArgs instead
     */
    export type AnsibleGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnsibleGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerDefaultArgs instead
     */
    export type ServerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvironmentDefaultArgs instead
     */
    export type EnvironmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvironmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareDefaultArgs instead
     */
    export type SoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareVersionDefaultArgs instead
     */
    export type SoftwareVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalDefaultArgs instead
     */
    export type ApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}